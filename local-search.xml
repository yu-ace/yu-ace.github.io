<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>声音克隆-GPT-SoVITS实操</title>
    <link href="/2024/01/05/%E5%A3%B0%E9%9F%B3%E5%85%8B%E9%9A%86-GPT-SoVITS%E5%AE%9E%E6%93%8D/"/>
    <url>/2024/01/05/%E5%A3%B0%E9%9F%B3%E5%85%8B%E9%9A%86-GPT-SoVITS%E5%AE%9E%E6%93%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="声音克隆-GPT-SoVITS实操"><a href="#声音克隆-GPT-SoVITS实操" class="headerlink" title="声音克隆-GPT-SoVITS实操"></a>声音克隆-GPT-SoVITS实操</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>随着大模型的发展，越来越多有趣的模型问世。本次所介绍的就是一款声音克隆模型，它可以分析一段音频，提取说话人的音色，将音频交给模型训练并推理，最终实现声音的克隆，这种克隆可以获取到音频的情感、音色和语速。</p><h2 id="2-前期准备"><a href="#2-前期准备" class="headerlink" title="2 前期准备"></a>2 前期准备</h2><p>模型名称为 __GPT-SoVITS__，推荐直接使用 <strong>github</strong> 下载，当然也可以从其他途径去获取。以Windows系统为例，下载完成后，打开资源包，双击 <strong>go-webui.bat</strong> 便会打开浏览器看到如下页面。如果没有跳出，也可以在浏览器中输入命令行给出的网址打开。</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E9%A6%96%E9%A1%B5%E7%95%8C%E9%9D%A2.png"></p><center>模型首页界面</center><h2 id="3-训练实战"><a href="#3-训练实战" class="headerlink" title="3 训练实战"></a>3 训练实战</h2><h3 id="3-1-去除噪音"><a href="#3-1-去除噪音" class="headerlink" title="3.1 去除噪音"></a>3.1 去除噪音</h3><p>首先，需要点击 <strong>Open UVR5-WebUI</strong> ,在跳出来的界面上进行操作。</p><p><img src="/images/%E5%8E%BB%E9%99%A4%E5%99%AA%E9%9F%B3%E7%95%8C%E9%9D%A2.png"></p><center>去除噪音界面打开方式</center><p>在打开的界面中，需要将我们的音频文件的存储路径复制到文本框中，然后按照需求选择对应的模型，同时需要指定音频分离以后的文件所保存的位置，并且格式需要确保为wav格式，然后确定即可。</p><p><img src="/images/%E5%8E%BB%E9%99%A4%E5%99%AA%E9%9F%B3%E6%93%8D%E4%BD%9C.png"></p><center>去除噪音操作</center><p>这一步操作完，一共会得到两个音频文件，一个是以instrument开头的伴奏文件，另一个是以vocal开头的人声文件。</p><h4 id="3-2-切割音频"><a href="#3-2-切割音频" class="headerlink" title="3.2 切割音频"></a>3.2 切割音频</h4><p>这一步需要将分离开的人声进行切割。首先输入原音频的文件夹路径，然后根据需要调整参数。主要的参数为min_length，主要依靠电脑显存大小来调整，显存越小数值也就越小。如果获取的音频太密集可以通过min_interval参数降低。其他参数建议使用默认选项，之后便进行音频切割。</p><p><img src="/images/%E5%88%87%E5%89%B2%E5%99%AA%E9%9F%B3.png"></p><center>切割音频</center><p>我们将切割完的文件进行中文识别，将音频转换为文字，可以更好地帮助我们校核音频。这里需要将切割后的文件夹路径放置到文本框，选定输出文件即可进行转换，转换完成后，可以将生成的文件路径放入到语音转文字校对工具中 <strong>.list annotation file path</strong> ,并且选中的 <strong>Open labelling WebUI</strong> ,在跳出的界面中进行文字比对，修改。当然如果不追求极致的效果，可以跳过该步骤。</p><p><img src="/images/%E9%9F%B3%E9%A2%91%E8%BD%AC%E6%96%87%E5%AD%97.png"></p><center>音频文字转换</center><h3 id="3-3-模型训练"><a href="#3-3-模型训练" class="headerlink" title="3.3 模型训练"></a>3.3 模型训练</h3><p>这一步，我们将正是进行模型的训练。我们需要在初始界面上，选择__1-GPT-SOVITS-TTS__ ，在model name中为自己的模型取名，然后在 <strong>Text labelling file</strong> 标签中,将之前生成的list文件路径放入，并将存储切割后音频文件的文件夹路径放入到 <strong>Audio dataset folder</strong> 中。然后就可以点击下面的三个选项，依次进行模型训练即可。</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83.png"></p><center>模型训练</center><p>训练完成后，便可以调整权重，进行深度学习。我们在 <strong>1B-Fine-tuned training</strong> 界面中，选择参数进行深度学习，这一步非常吃系统资源，不建议选择较高的数值。</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E6%9D%83%E9%87%8D%E8%AE%AD%E7%BB%83.png"></p><center>模型权重训练</center><h4 id="3-4-模型推理"><a href="#3-4-模型推理" class="headerlink" title="3.4 模型推理"></a>3.4 模型推理</h4><p>当完成权重训练以后，便可以进行推理了.我们需要选择 <strong>1C-inference</strong> 界面，在GPT模型列表和SoVITS模型里边中找到需要使用的模型，然后勾选 <strong>Open TTS inference WEBUI</strong> 选项，既可以跳出模型推理界面。</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86.png"></p><center>模型推理入口界面</center><p>在这里，我们就可以按照需求，使用训练的模型，模拟输入音频的音色进行文字转换。首先需要重新选择GPT模型列表和SoVITS模型。在__Please upload and fill reference information__中放入部分音频的分割文件，并且在对应的文本框中输入相应的中文，以供模型模拟，然后将需要转化的文字粘贴到inference text文本框中，然后转换即可。</p><p><img src="/images/%E6%A8%A1%E5%9E%8B%E6%8E%A8%E7%90%86%E7%95%8C%E9%9D%A2.png"></p><center>模型推理界面</center><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>按照上述内容操作，最后生成的声音虽然说不能100%一样，但还是很相似的。毕竟这是机器模拟，现在还不可能模拟出一摸一样的声音，但是随着大模型的发展，真正会有实现的那一天那不一定呢。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
      <category>GPT</category>
      
      <category>声音克隆</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAG运用-个人知识库实战</title>
    <link href="/2023/09/21/RAG%E8%BF%90%E7%94%A8-%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AE%9E%E6%88%98/"/>
    <url>/2023/09/21/RAG%E8%BF%90%E7%94%A8-%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="RAG运用-个人知识库实战"><a href="#RAG运用-个人知识库实战" class="headerlink" title="RAG运用-个人知识库实战"></a>RAG运用-个人知识库实战</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>RAG技术的应用需要外挂数据库来提供更时效性和准确性的信息，进而充分利用外部数据以提升LLM的能力。然而，在初次使用时，往往会感到无从下手。在此，我将以个人知识库为例，展示具体的操作方式，以期帮助大家更好地了解和运用该技术。</p><h2 id="2-前期准备"><a href="#2-前期准备" class="headerlink" title="2 前期准备"></a>2 前期准备</h2><p>运行环境：本篇所有的操作都是运行在JupyterLab上的，需自行安装。</p><p>OPENAI_API_KEY：是 OpenAI 提供的 API 密钥，用于访问 OpenAI GPT-3 模型以及其他相关的人工智能服务，需要自己去申请。</p><h2 id="3-代码实战"><a href="#3-代码实战" class="headerlink" title="3 代码实战"></a>3 代码实战</h2><h3 id="3-1-安装依赖"><a href="#3-1-安装依赖" class="headerlink" title="3.1 安装依赖"></a>3.1 安装依赖</h3><p>RAG主要依靠的就是向量数据库，这里使用了chromadb向量数据库，同时安装langchain和openai。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">!pip install langchain openai chromadb<br></code></pre></td></tr></table></figure><h3 id="3-2-索引文档到向量数据库"><a href="#3-2-索引文档到向量数据库" class="headerlink" title="3.2 索引文档到向量数据库"></a>3.2 索引文档到向量数据库</h3><h4 id="3-2-1-设置openai"><a href="#3-2-1-设置openai" class="headerlink" title="3.2.1 设置openai"></a>3.2.1 设置openai</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> OpenAI<br><br>os.environ[<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="hljs-string">&#x27;你的api key&#x27;</span><br><br></code></pre></td></tr></table></figure><p>这一步主要就是需要将自己申请的key设置为环境变量，以供后续使用。</p><h4 id="3-2-2-加载文档"><a href="#3-2-2-加载文档" class="headerlink" title="3.2.2 加载文档"></a>3.2.2 加载文档</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.document_loaders <span class="hljs-keyword">import</span> TextLoader<br><span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> CharacterTextSplitter<br><br>book_path=<span class="hljs-string">&quot;your path&quot;</span><br>loader = TextLoader(book_path)<br>documents = loader.load()<br><br><span class="hljs-comment"># 将文档按照章节切块</span><br>text_splitter = CharacterTextSplitter(chunk_size=<span class="hljs-number">1000</span>, chunk_overlap=<span class="hljs-number">0</span>)<br>docs = text_splitter.split_documents(documents)<br></code></pre></td></tr></table></figure><p>加载文档一共分为两步，第一步是加载路径内的文件，并且将数据转化为document对象。第二部是初始化一个切割器，将document对象切割成小块，便于向量数据库的存储。</p><h4 id="3-2-3-保存数据"><a href="#3-2-3-保存数据" class="headerlink" title="3.2.3 保存数据"></a>3.2.3 保存数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain.embeddings.openai <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><br>embeddings = OpenAIEmbeddings()<br>db = Chroma.from_documents(docs, embeddings)<br></code></pre></td></tr></table></figure><p>这一步主要目的就是计算embedding，并且将数据保存到向量数据库中。</p><h3 id="3-3-相关性检索"><a href="#3-3-相关性检索" class="headerlink" title="3.3 相关性检索"></a>3.3 相关性检索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">query = <span class="hljs-string">&quot;激励相容是什么&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;用户的问题是：<span class="hljs-subst">&#123;query&#125;</span>&quot;</span>)<br>some_query_result = db.similarity_search(query)<br><br>recall_result=<span class="hljs-string">&quot;&quot;</span><br>cnt = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i,r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(some_query_result):<br>    <span class="hljs-comment"># print(f&quot;第&#123;i&#125;条相似结果：&#123;r.page_content&#125;&quot;)</span><br>    recall_result = recall_result + <span class="hljs-string">&quot;\n\n&quot;</span>+r.page_content<br>    cnt = cnt + <span class="hljs-built_in">len</span>(r.page_content)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;共<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(some_query_result)&#125;</span>条相似内容，共<span class="hljs-subst">&#123;cnt&#125;</span>字&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">用户的问题是：激励相容是什么<br>共4条相似内容，共3281字<br></code></pre></td></tr></table></figure><p>对数据库内的数据进行搜索，统计并且打印所有检索出来的相关内容。</p><h3 id="3-4-LLM整合"><a href="#3-4-LLM整合" class="headerlink" title="3.4 LLM整合"></a>3.4 LLM整合</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">from</span> langchain <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> langchain.schema <span class="hljs-keyword">import</span> HumanMessage,SystemMessage<br><br>embeddings = OpenAIEmbeddings()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;用户的问题是：<span class="hljs-subst">&#123;query&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------正在计算，请稍候-----------&quot;</span>)<br>prompt_message = SystemMessage(<br>    content=<span class="hljs-string">&quot;你是一个文档总结机器人，请根据文档内容回答用户问题。文档内容为：&quot;</span>+recall_result<br>)<br>human_message=HumanMessage(content=query)<br>resp = model([prompt_message, human_message])<br><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;AI的回答是：<span class="hljs-subst">&#123;resp.content&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">用户的问题是：激励相容是什么</span><br><span class="hljs-literal">--------</span><span class="hljs-comment">正在计算，请稍候</span><span class="hljs-literal">-----------</span><br><span class="hljs-comment">AI的回答是：激励相容指的是一方有意愿并具备能力去完成另一方期望的事情。在政府内部，激励相容可以指上下级之间的激励相容，也可以指工作目标和官员自身利益之间的激励相容。具体来说，就是要求上级政府和下级政府之间的工作目标相互协调，上级政府既要提出明确的要求，又要给予下级政府足够的资源和支持，使得下级政府有能力并有意愿去完成上级政府的要求。同时，上级政府也要考虑到下级政府官员的个人利益，给予相应的激励，以促使他们积极地推动工作。这样的激励相容可以提高政府运作的效果。</span><br></code></pre></td></tr></table></figure><p>首先，需要加载OpenAI模型；然后将向量数据库中查询到的数据全部放入到promrt中，将提问放到human_message对象中，最后将两个对象都作为输入参数传递给模型，让模型输出最终的回答内容。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>上述过程展示了一个完整的外挂个人知识库的制作过程，使用了基于LLM的RAG技术。通过这种技术，AI可以回答其原本不具备的知识。</p><p>这种方法使得AI可以利用外部的知识资源来回答问题，即使它本身并不具备这些知识。通过引入文档总结作为提示信息，模型能够从中获取相关知识，并结合用户的问题生成准确的回答。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
      <category>RAG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go是否需要线程池</title>
    <link href="/2023/09/19/Go%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/09/19/Go%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Go是否需要线程池"><a href="#Go是否需要线程池" class="headerlink" title="Go是否需要线程池"></a>Go是否需要线程池</h1><h2 id="1-Java中的线程池"><a href="#1-Java中的线程池" class="headerlink" title="1 Java中的线程池"></a>1 Java中的线程池</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>熟悉Java的人都知道，多线程作为一种并发编程技术，可以通过在一个程序中同时运行多个线程，来提高程序的执行效率和响应速度。很多时候，我们会通过线程池来实现多线程运用，那么java都有哪些线程池呢？</p><h3 id="1-2-Java线程池"><a href="#1-2-Java线程池" class="headerlink" title="1.2 Java线程池"></a>1.2 Java线程池</h3><p><strong>FixedThreadPool（固定线程池）</strong>:该线程池包含固定数量的线程，适合处理数量已知且较小的任务。当所有线程都处于活动状态时，新的任务会被放入等待队列中。</p><p><strong>CachedThreadPool（缓存线程池）</strong>:创建一个可缓存线程池，线程池的线程数量不固定，可以根据任务的数量动态调整。如果线程池中有空闲线程，则会重复利用它们，否则会创建新的线程。适用于大量短期任务的场景。</p><p><strong>SingleThreadExecutor（单线程池）</strong>:该线程池只包含一个线程，用于按顺序执行任务。适合需要保证任务顺序执行的场景，比如单线程执行文件的读写操作。</p><p><strong>ScheduledThreadPool（定时线程池）</strong>:这个线程池可用于按延迟或定时周期执行任务。可以通过schedule方法设定任务的执行时间。</p><p><strong>WorkStealingPool（工作窃取线程池）</strong>:这线程池是Java 8新增的一种线程池。它是一种拥有多个工作队列的线程池，可以提高任务的并行度。每个线程都有自己的工作队列，当线程完成自己队列中的任务后，可以从其他线程的队列中窃取任务执行。</p><h3 id="1-3-线程池的作用"><a href="#1-3-线程池的作用" class="headerlink" title="1.3 线程池的作用"></a>1.3 线程池的作用</h3><p>Java创建线程时使用线程池的主要目的，就是避免频繁地创建和销毁线程带来的开销，充分利用内核，同时有效地控制并发线程的数量，防止过多的线程造成系统资源的浪费和线程切换的开销。</p><h2 id="2-Java和Go的异同"><a href="#2-Java和Go的异同" class="headerlink" title="2 Java和Go的异同"></a>2 Java和Go的异同</h2><p>Java拥有许多种线程池，同时也拥有第三方库对Java线程池的支持。那么在Go语言中，是否需要线程池呢？首先我们先对比一下两种语言的差异。</p><h3 id="2-1-相同点"><a href="#2-1-相同点" class="headerlink" title="2.1 相同点"></a>2.1 相同点</h3><p>__支持并发编程__：Java和Go都提供了原生支持并发编程的机制，使得开发者能够轻松地创建和管理多个并发执行的线程。</p><p>__提供线程抽象__：两者都提供了高级的线程抽象，如Java中的Thread类和Runnable接口，以及Go中的goroutine。</p><p>__支持锁和同步__：Java和Go都提供了锁和同步机制，如Java中的synchronized关键字和Lock接口，以及Go中的互斥锁（Mutex）和通道（Channel）等。</p><h3 id="2-2-不同点"><a href="#2-2-不同点" class="headerlink" title="2.2 不同点"></a>2.2 不同点</h3><p>__语言特性__：Java是一种面向对象的语言，而Go是一种面向过程和函数式编程的语言。这导致在多线程编程时，两种语言的代码风格和实现方式有所不同。</p><p>__并发模型__：Java 中 CPU 资源分配对象是 Thread，Go 中 CPU 资源分配对象是 goroutine。Java Thread 与系统线程为一一对应关系，goroutine 是 Go 实现的用户级线程，与系统线程是 m:n 关系。</p><h2 id="3-Go是否需要线程池"><a href="#3-Go是否需要线程池" class="headerlink" title="3 Go是否需要线程池"></a>3 Go是否需要线程池</h2><p>从1.3的内容可以看出线程池在Java中的作用，那么Go是否有这样的问题呢，我们得从Go的并发模型特点出发，Go鼓励使用goroutine和通道来启动轻量级的并发执行单元，而不是直接操作线程。goroutine创建和销毁开销很小，因此可以创建大量的goroutine，并行执行任务。此外，通过使用通道进行同步和通信，可以确保数据的安全访问。</p><p>由此可见，对于Go本身而言，是不需要线程池的。但如果必须使用线程池，可以通过一些第三方库来实现类似线程池的功能。一些常用的库包括<code>golang.org/x/sync/semaphore</code>、<code>github.com/Workiva/go-datastructures/workerpool</code>等。这些库通常允许你创建一组固定数量的goroutine，并将任务提交到池中进行执行。它们会自动管理goroutine的生命周期，避免过度创建和销毁。</p><h2 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4 代码实现"></a>4 代码实现</h2><h3 id="4-1-Java线程池实现"><a href="#4-1-Java线程池实现" class="headerlink" title="4.1 Java线程池实现"></a>4.1 Java线程池实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> ExecutorBuilder.create()<br>            .setCorePoolSize(<span class="hljs-number">2</span>)<br>            .setMaxPoolSize(<span class="hljs-number">2</span>)<br>            .setWorkQueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>))<br>            .build();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                add();<br>            &#125;<br>        &#125;);<br>        Future&lt;?&gt; future1 = executorService.submit(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                add();<br>            &#125;<br>        &#125;);<br>        future.get();<br>        future1.get();<br>        System.out.println(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Go多线程"><a href="#4-2-Go多线程" class="headerlink" title="4.2 Go多线程"></a>4.2 Go多线程</h3><p>根据Go语言对于线程池的态度，在此就是用常规的写法实现Go的多线程写法，不使用第三方库来实现多线程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> j <span class="hljs-type">int32</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> mutex sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br>mutex.Lock()<br>j++<br>mutex.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>add()<br>&#125;<br><span class="hljs-keyword">defer</span> wg.Done()<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>add()<br>&#125;<br><span class="hljs-keyword">defer</span> wg.Done()<br>&#125;()<br>wg.Wait()<br>fmt.Println(j)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>Go语言本身不拥有线程池，因为它使用的是goroutine和通道来实现并发和并行。当然这并不是说它不支持线程池，在运用中，如果需要限制程序的并发量，也是可以通过第三方库来实现线程池运用的。</p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
      <category>Java</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java和Go对比</title>
    <link href="/2023/09/02/Java%E5%92%8CGo%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/09/02/Java%E5%92%8CGo%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h1 id="Java和Go对比"><a href="#Java和Go对比" class="headerlink" title="Java和Go对比"></a>Java和Go对比</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Java 是一种面向对象的编程语言，旨在提供并发性和跨平台可移植性。它具有强大的类和对象模型，支持面向对象编程范式，并且拥有丰富的类库和生态系统。后端开发领域得到广泛应用，尤其是在大型互联网平台，如淘宝、京东等。</p><p>Go 是一种面向过程的编程语言，于 2009 年由 Google 发布。它注重运行性能和开发效率，具有优秀的并发编程支持，在多处理器环境下表现出色。随着大数据的发展，越来越多的开发人员开始尝试使用 Go 语言构建大型并发式服务。</p><h2 id="2-两种语言比较"><a href="#2-两种语言比较" class="headerlink" title="2 两种语言比较"></a>2 两种语言比较</h2><p>目前很多人都在推崇Go语言，并且推荐想学习编程的人不要卷Java，而是直接入门Go语言，可以更快的上手。关于这种观点，我们得从两种语言的特性来对比，到底是怎么回事。</p><h3 id="2-1-Java的特点"><a href="#2-1-Java的特点" class="headerlink" title="2.1 Java的特点"></a>2.1 Java的特点</h3><p>Java作为目前使用最普遍的编程语言，是因为它经历了20多年，一直在不断地更新推出版本。它通过JVM虚拟机，实现了“一次编译，多次运行”，主要是通过编译器将代码编译成二进制文件，然后在虚拟机上运行二进制文件，所以只需要其他平台有虚拟机，就可以实现Java的跨平台运行。当然这也导致了Java运行时的臃肿，需要浪费一部分资源，增加了Java程序的大小。</p><p>Java是一门面向对象的语言，拥有封装、继承、多态三大特性。Java中的所有内容都被视为对象，类是对象的模板，它描述了对象的状态和行为。</p><p>在线程方面，Java采用的是内核线程，是直接由操作系统内核支持的线程，由内核来实现线程的切换，这也就导致了各种线程操作都需要进行系统调用，它的代价比较大，需要在用户态和内核态来回切换，需要消耗一定的内核资源。</p><p>同时，Java还拥有丰富的第三方库的支持，开发人员可以在应用程序中使用它们来完成很多任务，可以极大的提升开发的效率。</p><h3 id="2-2-Go的特点"><a href="#2-2-Go的特点" class="headerlink" title="2.2 Go的特点"></a>2.2 Go的特点</h3><p>Go是一种极简主义的语言。没有类的概念，而是通过结构体的方式来表示。他不是面向对象的，没有传统意义上的继承和反射，而是通过组合和嵌入结构体来实现系统构建。</p><p>GO通过编译成可执行文件来实现跨平台运行。主要是通过它的编码器，在编译时针对不同的平台编译成不同的执行文件，从而实现在对应的平台运行。由于Go运行环境就是系统环境，没有JVM的存在，所以Go程序通常会比较小。</p><p>Go在线程方面，采用的是用户线程，它是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在和实现，所以如果程序实现得当，它的线程不需要切换到内核态，所以线程操作可以非常快速并且消耗较低的资源。</p><h2 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3 适用场景"></a>3 适用场景</h2><p>Java广泛应用于企业级应用、大型系统、Android应用等领域。由于其稳定性、强大的生态系统和广泛的支持，Java在企业级开发中占有重要地位。</p><p>Go由于其简洁性、高效性和优秀的并发模型，在云计算、分布式系统、网络编程等领域表现出色。在构建高并发、高性能的服务器应用和微服务方面具有优势。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>作为不同的语言，他们都有着各自的特点，在这些特点的作用下，产生了各自的优势和劣势。我们不能说哪一种语言更好，而是只能说哪一种语言更加符合场景，更加符合项目的需要。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FastChat实战—部署个人私有大模型服务</title>
    <link href="/2023/07/15/FastChat%E5%AE%9E%E6%88%98%E2%80%94%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/07/15/FastChat%E5%AE%9E%E6%88%98%E2%80%94%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E7%A7%81%E6%9C%89%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="FastChat实战—部署个人私有大模型服务"><a href="#FastChat实战—部署个人私有大模型服务" class="headerlink" title="FastChat实战—部署个人私有大模型服务"></a>FastChat实战—部署个人私有大模型服务</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>FastChat是一个用于训练、提供服务和评估基于大型语言模型的聊天机器人的开放平台。其核心特点包括：最先进模型（例如 Vicuna）的权重、训练代码和评估代码。带有 WebUI 和与 OpenAI 兼容的 RESTful API 的分布式多模型服务系统。</p><p>本篇主要是以ubuntu系统下的模型部署</p><h2 id="2-配置环境"><a href="#2-配置环境" class="headerlink" title="2 配置环境"></a>2 配置环境</h2><h3 id="2-1-安装Navia驱动"><a href="#2-1-安装Navia驱动" class="headerlink" title="2.1 安装Navia驱动"></a>2.1 安装Navia驱动</h3><p>首先需要检查服务器是否安装gcc，如果没有安装，则需要进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc -v<br>sudo apt-get install build-essential<br></code></pre></td></tr></table></figure><p>在安装完gcc之后，需要通过编辑 &#x2F;etc&#x2F;modprobe.d&#x2F;blacklist-nouveau.conf 文件来禁用nouveau驱动，在文件末尾添加下列代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">blacklist nouveau<br>blacklist lbm-nouveau<br>options nouveau modeset=0<br>alias nouveau off<br>alias lbm-nouveau off<br></code></pre></td></tr></table></figure><p>随后需要重新生成内核并重启，再执行第三行命令，执行后如果屏幕没有内容输出，说明nouveau驱动禁用成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo update-initramfs -u<br>sudo reboot<br>lsmod | grep nouveau<br></code></pre></td></tr></table></figure><p>使用获取命令 <strong>ubuntu-drivers devices</strong> 获取所用的驱动信息，并选择合适的版本进行安装，安装后执行 <strong>nvidia-smi</strong> 可以看到gpu监控界面，其中会展示cuda版本，后面需要使用。 </p><h3 id="2-2-安装cuda"><a href="#2-2-安装cuda" class="headerlink" title="2.2 安装cuda"></a>2.2 安装cuda</h3><p>在cuda官网中找到上面提到的cuda版本对应的版本包之后，使用runfile的方式进行安装，这里我已11.4版本为例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://developer.download.nvidia.com/compute/cuda/11.4.0/local_installers/cuda_11.4.0_470.42.01_linux.run<br>sudo sh cuda_11.4.0_470.42.01_linux.run<br></code></pre></td></tr></table></figure><h3 id="2-3-安装Anaconda"><a href="#2-3-安装Anaconda" class="headerlink" title="2.3 安装Anaconda"></a>2.3 安装Anaconda</h3><p>登录 <strong><a href="https://repo.anaconda.com/archive/">Index of &#x2F; (anaconda.com)</a></strong> 选择需要安装的版本，使用 <strong>wget</strong> 命令进行下载，以 <strong>Anaconda3-5.3.0-Linux-x86_64.sh</strong> 为例，然后依次执行下面的命令进行程序安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x Anaconda3-5.3.0-Linux-x86_64.sh<br>./Anaconda3-5.3.0-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>在终端输入 <strong>anaconda -V</strong> ,显示版本信息，若显示则表示安装成功。</p><h3 id="2-4-Anaconda安装Pytorch"><a href="#2-4-Anaconda安装Pytorch" class="headerlink" title="2.4 Anaconda安装Pytorch"></a>2.4 Anaconda安装Pytorch</h3><p>首先需要创建虚拟环境，并激活，分别执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda create -n 自己取名 python=需要的版本号<br>conda activate 自己取名<br></code></pre></td></tr></table></figure><p>在 <strong><a href="https://pytorch.org/">PyTorch</a></strong> 官网上，选择安装的Pytorch版本，并运行它提供的命令。</p><p><img src="/images/PyTorch.png"></p><center>PyTorch版本选择示意</center><h2 id="3-安装FastChat"><a href="#3-安装FastChat" class="headerlink" title="3 安装FastChat"></a>3 安装FastChat</h2><p>需要在github上拉取代码，并进行安装，具体命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/lm-sys/FastChat.git<br>cd FastChat<br>pip3 install --upgrade pip  <br>pip3 install -e .<br></code></pre></td></tr></table></figure><p>安装完成以后，就可以运行模型了，这里以13B模型为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m fastchat.serve.cli --model-path lmsys/vicuna-13b-v1.3<br></code></pre></td></tr></table></figure><p>如果在运行过程中报错，很有可能是因为文件过大，无法一次性将文件全部下下来，需要多次执行命令，直到完成为止。</p><p><img src="/images/13B%E6%8A%A5%E9%94%99.png"></p><center>13B报错</center><h3 id="4-创建UI界面"><a href="#4-创建UI界面" class="headerlink" title="4 创建UI界面"></a>4 创建UI界面</h3><p>在模型成功运行以后，可以在终端中执行下面命令，创建一个UI界面，方便使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 -m fastchat.serve.controller<br>python3 -m fastchat.serve.model_worker --model-path lmsys/vicuna-13b-v1.3<br>python3 -m fastchat.serve.gradio_web_server<br></code></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>以上便是从零开始，在一个全新的服务器上部署一个FastChat模型的全过程。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
      <category>FastChat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RAG入门</title>
    <link href="/2023/07/13/RAG%E5%85%A5%E9%97%A8/"/>
    <url>/2023/07/13/RAG%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="RAG入门"><a href="#RAG入门" class="headerlink" title="RAG入门"></a>RAG入门</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>RAG（检索增强生成，英文名：Retrieval Augmented Generation）是使用外部知识源的检索和大语言模型相结合的应用，LLM可以通过这个技术来增强生成的回复内容。</p><p>RAG主要包含检索和生成两部分的内容。生成指的是系统搜索庞大的数据库或存储库以查找相关信息的过程；生成是在检索完成以后，系统生成类似人类的文本，整合获取数据。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h2><p>LLM有多个痛点，比如时效性问题，它无法获取到最新发生的事情的内容，内部的知识库还停留在2021年的数据；比如会出现幻觉，它会产生大量不准确的或者是误导性的内容输入，这主要是因为它是通过当前输出的字来计算下一个字出现的概率，这就非常容易导致幻觉的出现。</p><p>面对LLM所存在的缺陷，RAG就可以较好地解决这方面的问题。通过外挂数据库，就可以使LLM在回答问题或者生成文本时，不仅可以从本身包含的大量文档中检索内容，也会从外挂的数据库中检索出相关信息，这样就可以获取到最新时效的内容，也能使其回答更准确。</p><p><img src="/images/rag%E6%AD%A5%E9%AA%A4.png"></p><center>RAG主要流程图</center><h2 id="3-特点"><a href="#3-特点" class="headerlink" title="3 特点"></a>3 特点</h2><p>动态数据。通过RAG，可以不断的查询外部数据，确保信息的时效性，而且不需要频繁的训练模型。</p><p>可以较好的利用外部数据。通过在生成响应之前从知识源检索相关信息来增强LLM能力，非常适合文档或其他结构化&#x2F;非结构化数据库，通过这些数据，RAG是不太可能出现幻觉的，因为它的每一个回答都建立在检索到的内容上。</p><h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4 缺点"></a>4 缺点</h2><p>信息丢失：RAG 的流程链中的每个步骤都是有损的，意味着并不是所有的信息都能被保留在结果中。分块和嵌入过程、检索过程以及回复生成过程都可能导致信息的丢失。</p><p>复杂性和可调性：RAG 需要对参数进行调优，例如块大小和 top_k 值，以确保系统的最佳性能。这需要花费一定的时间和精力来调整超参数。</p><p>语义相似性搜索的局限性：RAG 在语义相似性搜索方面存在局限性。虽然它可以根据文本的相似度来检索相关信息，但并不能保证总是能得到理想的结果。</p><p>缺乏常识和推理能力：RAG 系统缺乏常识和推理能力。它无法理解人类具有的常识和背景知识，因此在某些情况下可能会给出不准确或不完整的答案。</p><p>多跳问答问题：RAG 在处理多跳问答问题时存在困难。由于块大小和 top_k 的限制，它可能无法完成复杂的推理任务，导致结果不完整或不准确。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>RAG技术的发展和应用需要持续关注和研究，以克服其中的挑战并最大程度地发挥其潜力。随着人工智能和自然语言处理领域的不断发展，RAG技术有望成为改善语言模型生成能力和知识获取效率的重要工具，为各行业带来更多创新应用和解决方案。</p>]]></content>
    
    
    <categories>
      
      <category>大模型</category>
      
      <category>RAG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="/2023/04/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/04/17/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Java的一门编译与解释并存的语言。其中编译指的就是将代码（.java）编译成虚拟机可以识别理解的字节码(.class)，也就是所谓的Class文件。</p><p>而虚拟机的类加载机制，就是指虚拟机把描述类的数据从Class文件中加载到内存，并对数据进行校验、转换解析等操作，最后形成可以被虚拟机直接使用的Java类型的过程。</p><h2 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2 类加载过程"></a>2 类加载过程</h2><p>一个类型从被加载到虚拟机内存，再到卸载出内存为止，它的整个生命周期会经历加载、连接、初始化、使用和卸载五个阶段，其中连接里面又包含验证、准备和解析三个阶段。</p><p><img src="/images/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png"></p><center>类加载过程</center><h3 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 加载</h3><p>加载是整个类加载过程中的一个阶段。在这个阶段，虚拟机要经历三个阶段，第一阶段是通过一个类名获取该类的字节流；第二阶段是将字节流的静态存储结构转换为方法区的运行时数据结构；第三阶段是再内存中生成这类的java.lang.Class对象，作为方法区对这个类各种数据的访问入口。</p><h3 id="2-2-连接"><a href="#2-2-连接" class="headerlink" title="2.2 连接"></a>2.2 连接</h3><p>加载阶段和连接阶段的部分动作是交叉进行的，加载阶段没有完成，连接阶段可能已经开始了。</p><h4 id="2-2-1-验证"><a href="#2-2-1-验证" class="headerlink" title="2.2.1 验证"></a>2.2.1 验证</h4><p>验证是连接阶段的第一步。这一步需要确保Class文件的字节流中的信息符合规范要求，并且不会被当作代码运行后危害虚拟机安全。</p><p>验证阶段主要是对文件格式、元数据、字节码和符号引用进行验证。</p><h4 id="2-2-2-准备"><a href="#2-2-2-准备" class="headerlink" title="2.2.2 准备"></a>2.2.2 准备</h4><p>准备阶段是正式为类中定义的变量分配内存空间并设置变量初始值的阶段。不过需要注意的是，内存分配的仅仅包括类变量，不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中，而且初始值都是默认值，而不是变量中定义的值。</p><h4 id="2-2-3-解析"><a href="#2-2-3-解析" class="headerlink" title="2.2.3 解析"></a>2.2.3 解析</h4><p>这个阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。</p><h3 id="2-3-初始化"><a href="#2-3-初始化" class="headerlink" title="2.3 初始化"></a>2.3 初始化</h3><p>类初始化是类加载过程中的最后一个步骤。到这一步，虚拟机才真正开始执行类中编写的Java程序。</p><h2 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3 类加载器"></a>3 类加载器</h2><p>类加载器是实现类加载动作的工具，他在Java程序中的作用非常大。任意一个类都需要由加载它的类加载器和这个类本身一起共同确立它在Java虚拟机的唯一性，每一个类加载器都有一个独立的类名空间。也就是说，如果两个类是由两个不同的类加载器加载的，那么他们必然是不相同的。</p><h3 id="3-1-双亲委派模型"><a href="#3-1-双亲委派模型" class="headerlink" title="3.1 双亲委派模型"></a>3.1 双亲委派模型</h3><p>在Java语言系统中，一共支持4类加载器，分别是启动类加载器、扩展类加载器、应用程序类加载器和自定义类加载器。如下图所示，这就是一个双亲委派模型，双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应该有自己的父类加载器。</p><p><img src="/images/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png"></p><center>双亲委派模型</center><p>双亲委派机制，其实就是如果一个类加载器收到了类加载的请求，他会向上反馈给自己的父类加载器去完成加载，所以一般都是由最顶层的启动类加载器完全加载请求。只有当父类反馈无法加载时，才会由子类其加载。</p><p>使用双亲委派机制的好处就是，通过双亲委派机制，无论是哪一个类加载器加载一个类，最终都会向上委派给启动类加载器去加载，这样就可以确保该类在各种类加载器环境中都能保证是同一个类。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机性能监控和处理</title>
    <link href="/2023/02/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <url>/2023/02/23/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机性能监控和处理"><a href="#虚拟机性能监控和处理" class="headerlink" title="虚拟机性能监控和处理"></a>虚拟机性能监控和处理</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>众所周知，Java的一大特点是平台无关性。所谓的平台无关性就是Java是一次编写，到处运行，Java之所以能做到这一点，最主要的就是因为它是运行在虚拟机上的，通过虚拟机来实现跨平台使用。但是有些人对于虚拟机的了解仅到此而已，并不知道在程序运行时，如何检测虚拟机的性能，或者当程序发生问题时，如何处理故障。</p><h2 id="2-工具介绍"><a href="#2-工具介绍" class="headerlink" title="2 工具介绍"></a>2 工具介绍</h2><p>随着JDK版本的更迭，JDK的bin目录下的小工具的数量和功能也越发的强大，在很多场景都可以使用到这些工具。</p><p><img src="/images/JDK%E7%9A%84bin%E7%9B%AE%E5%BD%95.png"></p><center>JDK自带工具</center><p>下面，我们需要运行一段代码，并且通过这些工具，来找到所运行的代码存在说明问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">task3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br>        task3.start();<br>        task1.start();<br>        task2.start();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            lock.lock();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center>Java示例代码</center><h3 id="2-1-虚拟机进程状态"><a href="#2-1-虚拟机进程状态" class="headerlink" title="2.1 虚拟机进程状态"></a>2.1 虚拟机进程状态</h3><p>首先，我们通过JDK工具中经典的 <strong>jps</strong> 工具。通过这个命令，可以列出所有正在运行的虚拟机进程，并显示虚拟机执行主类名称和唯一ID。</p><p>通过使用 <strong>jps -l</strong> 命令，就可以将所有的的运行进程列表展示出来。如下图所示，运行的Demo的ID号为 183496。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">jps -l<br>186512 org.jetbrains.jps.cmdline.Launcher<br>183496 org.example.Demo<br>187420 jdk.jcmd/sun.tools.jps.Jps<br></code></pre></td></tr></table></figure><h3 id="2-2-统计信息"><a href="#2-2-统计信息" class="headerlink" title="2.2 统计信息"></a>2.2 统计信息</h3><p><strong>jstat</strong> 是用于监视虚拟机各种运行状态信息的命令行工具，通过这个命令，可以显示虚拟机中类加载、内存、垃圾回收等运行时数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">jstat -gc 183496<br>S0C         S1C         S0U         S1U          EC           EU           OC           OU          MC         MU       CCSC      CCSU     YGC     YGCT     FGC    FGCT     CGC    CGCT       GCT<br>   0.0         0.0         0.0         0.0      28672.0       4096.0     487424.0          0.0        0.0        0.0       0.0       0.0      0     0.000     0     0.000     0     0.000     0.000<br></code></pre></td></tr></table></figure><p>如上图数据所示，S0C、S1C分别代表第一、第二幸存区的大小；S0U、S1U代表第一、第二幸存区的使用大小；EC、EU代表伊甸园区的大小和使用大小；OC、OU代表老年代大小和使用大小；MC、MU代表发放区大小和使用大小；CCSC、CCSU分别是压缩类空间大小和使用大小；YGC、YGCT则代表年轻代垃圾回收次数和消耗的时间；FGC、FGCT是老年代垃圾回收次数和消耗时间；CGC、CGCT表示并发垃圾回收次数和消耗时间；GCT则表示垃圾回收总消耗时间。</p><h3 id="2-3-Java配置信息"><a href="#2-3-Java配置信息" class="headerlink" title="2.3 Java配置信息"></a>2.3 Java配置信息</h3><p><strong>jinfo</strong> 是实时查看和调整虚拟机各项参数的工具，它可以查看到运行的Java版本、CPU型号，系统，程序名称等信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">jinfo 183496<br>Java System Properties:<br>java.specification.version=17<br>sun.cpu.isalist=amd64<br>sun.jnu.encoding=GBK<br>...<br>os.name=Windows 11<br>java.vm.specification.version=17<br>sun.java.launcher=SUN_STANDARD<br>user.country=CN<br>sun.boot.library.path=C\:\\Program Files\\Java\\jdk-17.0.4.1\\bin<br>sun.java.command=org.example.Demo<br>...<br></code></pre></td></tr></table></figure><h3 id="2-4-Java堆栈跟踪工具"><a href="#2-4-Java堆栈跟踪工具" class="headerlink" title="2.4 Java堆栈跟踪工具"></a>2.4 Java堆栈跟踪工具</h3><p><strong>jstack</strong> 命令是用于虚拟机当前时刻的线程快照，也就是当前虚拟机内每一条线程正常在执行的方法堆栈的集合。主要是用来定位线程出现长时间停顿的原因，如线程间死锁、死循环等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"> jstack 183496<br>...<br>&quot;Thread-2&quot; #26 prio=5 os_prio=0 cpu=2875890.62ms elapsed=3618.37s tid=0x000001c2ff83bda0 nid=0x2cca4 runnable  [0x000000464c6fe000]<br>   java.lang.Thread.State: RUNNABLE<br>        at org.example.Demo$Task.run(Demo.java:22)<br>        at java.lang.Thread.run(java.base@17.0.4.1/Thread.java:833)<br><br>   Locked ownable synchronizers:<br>        - &lt;0x0000000628a65e90&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)<br><br>&quot;Thread-0&quot; #24 prio=5 os_prio=0 cpu=0.00ms elapsed=3618.37s tid=0x000001c2ff83c270 nid=0x2cad8 waiting on condition  [0x000000464c7ff000]<br>   java.lang.Thread.State: WAITING (parking)<br>        at jdk.internal.misc.Unsafe.park(java.base@17.0.4.1/Native Method)<br>        - parking to wait for  &lt;0x0000000628a65e90&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)<br>        at java.util.concurrent.locks.LockSupport.park(java.base@17.0.4.1/LockSupport.java:211)<br>        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(java.base@17.0.4.1/AbstractQueuedSynchronizer.java:715)<br>        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(java.base@17.0.4.1/AbstractQueuedSynchronizer.java:938)<br>        at java.util.concurrent.locks.ReentrantLock$Sync.lock(java.base@17.0.4.1/ReentrantLock.java:153)<br>        at java.util.concurrent.locks.ReentrantLock.lock(java.base@17.0.4.1/ReentrantLock.java:322)<br>        at org.example.Demo$Task.run(Demo.java:19)<br>        at java.lang.Thread.run(java.base@17.0.4.1/Thread.java:833)<br><br>   Locked ownable synchronizers:<br>        - None<br><br>&quot;Thread-1&quot; #25 prio=5 os_prio=0 cpu=0.00ms elapsed=3618.37s tid=0x000001c2ff841760 nid=0x28e88 waiting on condition  [0x000000464c8ff000]<br>   java.lang.Thread.State: WAITING (parking)<br>        at jdk.internal.misc.Unsafe.park(java.base@17.0.4.1/Native Method)<br>        - parking to wait for  &lt;0x0000000628a65e90&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)<br>        at java.util.concurrent.locks.LockSupport.park(java.base@17.0.4.1/LockSupport.java:211)<br>        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(java.base@17.0.4.1/AbstractQueuedSynchronizer.java:715)<br>        at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquire(java.base@17.0.4.1/AbstractQueuedSynchronizer.java:938)<br>        at java.util.concurrent.locks.ReentrantLock$Sync.lock(java.base@17.0.4.1/ReentrantLock.java:153)<br>        at java.util.concurrent.locks.ReentrantLock.lock(java.base@17.0.4.1/ReentrantLock.java:322)<br>        at org.example.Demo$Task.run(Demo.java:19)<br>        at java.lang.Thread.run(java.base@17.0.4.1/Thread.java:833)<br><br>   Locked ownable synchronizers:<br>        - None<br></code></pre></td></tr></table></figure><p>如上图所示，Thread-2的线程处于运行状态（RUNNABLE），持有“0x0000000628a65e90”的锁；Thread-0线程处于等待状态（WAITING），等待“0x0000000628a65e90”的锁；Thread-1线程处于等待状态（WAITING），也在等待“0x0000000628a65e90”的锁。</p><p>由此可见，该demo的问题是因为Thread-2长时间占用着锁，不释放，最终导致了出现死锁的情况出现。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>JDK自带的工具是我们开发过程中非常重要的助手，掌握它们的使用对于提高开发效率和代码质量至关重要。本文中列举的只是比较常用的命令。具体还有其他好用的工具，还需要平时积累，通过阅读文档、实际项目应用等方式来学习和掌握它们的使用。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>虚拟机</category>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COW和MOR</title>
    <link href="/2023/02/15/COW%E5%92%8CMOR/"/>
    <url>/2023/02/15/COW%E5%92%8CMOR/</url>
    
    <content type="html"><![CDATA[<h1 id="COW和MOR"><a href="#COW和MOR" class="headerlink" title="COW和MOR"></a>COW和MOR</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>相信很多人看到Copy On Write都不会太陌生，因为早在学习ArrayList时候，就接触过ArrayList不是线程安全的，想要实现线程安全的一种方法就是使用CopyOnWriteArrayList。其中这里的CopyOnWriteArrayList使用的就是Copy On Write的技术。</p><p>Copy On Write(COW)是写时复制，从名字就可以看出它是在数据写入的时候进行操作；那么我们可以设想一下是否有一种相反的方法，可以在数据读取的时候进行操作。Merge On Read(MOR)就是这种方法， 称为读时合并。</p><h2 id="2-Copy-On-Write"><a href="#2-Copy-On-Write" class="headerlink" title="2 Copy On Write"></a>2 Copy On Write</h2><h3 id="2-1-思想解读"><a href="#2-1-思想解读" class="headerlink" title="2.1 思想解读"></a>2.1 思想解读</h3><p>Copy On Write思想，简单来说就是多个进程在访问同一资源时候，不会进行数据的操作，访问的都属是同一个资源。只有在进行写操作时，会复制一份数据副本，期间所有的读操作依旧读取原始数据，写操作在副本上进行，写入完成后再更新指针。</p><h3 id="2-2-适用场景"><a href="#2-2-适用场景" class="headerlink" title="2.2 适用场景"></a>2.2 适用场景</h3><p>在读多写少的情境下效率较高。例如配置、黑名单、物流地址等变化非常少的数据，这是一种无锁的实现。可以帮我们实现程序更高的并发。</p><h3 id="2-3-缺点"><a href="#2-3-缺点" class="headerlink" title="2.3 缺点"></a>2.3 缺点</h3><p>数据一致性问题。这种实现只是保证数据的最终一致性，在添加到拷贝数据而还没进行替换的时候，读到的仍然是旧数据。</p><p>内存占用问题。如果对象比较大，频繁地进行替换会消耗内存，从而引发 Java 的 GC 问题，这个时候，我们应该考虑其他的容器。</p><h2 id="3-Merge-On-Read"><a href="#3-Merge-On-Read" class="headerlink" title="3 Merge On Read"></a>3 Merge On Read</h2><h3 id="3-1-思想解读"><a href="#3-1-思想解读" class="headerlink" title="3.1 思想解读"></a>3.1 思想解读</h3><p>Merge On Read思想，是指新插入的数据都存储在delta log中。定期将delta log合并进行parquet数据文件。数据读取时，会将delta log和老数据做merge，得出完整的数据返回。当然它也可以忽略delta log，只读取最近的完整数据文件。</p><h3 id="3-2-适用场景"><a href="#3-2-适用场景" class="headerlink" title="3.2 适用场景"></a>3.2 适用场景</h3><p>适用于写多读少的场景。由于写入数据先写delta log，且delta log较小，所以写入成本较低。</p><h3 id="3-3-缺点"><a href="#3-3-缺点" class="headerlink" title="3.3 缺点"></a>3.3 缺点</h3><p>需要定期合并整理compact，否则会产生较多的碎片文件。</p><p>查询延迟性较大。在对数据进行读取时，需要合并delta log和老数据文件，导致读取性能较差。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>COW和MOR是两种常用的存储格式，但是它们拥有完全相反的思想，选择了错误的方法会造成很大的麻烦。所以在技术选择上，我们需要区分好两者的特点，选择合适的技术运用到自己的项目中去。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解HDFS：存储大数据的利器与局限性</title>
    <link href="/2023/01/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HDFS%EF%BC%9A%E5%AD%98%E5%82%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A9%E5%99%A8%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7/"/>
    <url>/2023/01/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HDFS%EF%BC%9A%E5%AD%98%E5%82%A8%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A9%E5%99%A8%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解HDFS：存储大数据的利器与局限性"><a href="#深入理解HDFS：存储大数据的利器与局限性" class="headerlink" title="深入理解HDFS：存储大数据的利器与局限性"></a>深入理解HDFS：存储大数据的利器与局限性</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>HDFS （Hadoop Distributed File System）是 Hadoop 下的分布式文件系统，具有高容错、高吞吐量等特性，可以部署在低成本的硬件上。是 Hadoop 核心组件之一，作为最底层的分布式存储服务而存在。</p><h2 id="2-HDFS的作用"><a href="#2-HDFS的作用" class="headerlink" title="2 HDFS的作用"></a>2 HDFS的作用</h2><h3 id="2-1-大数据面临的问题"><a href="#2-1-大数据面临的问题" class="headerlink" title="2.1 大数据面临的问题"></a>2.1 大数据面临的问题</h3><p>随着大数据的快速发展，对数据的存储需求也不断增加。单个服务器已无法满足用户的需求，这不可避免地导致了需要对服务器进行扩充的局面。然而，随着服务器数量数量的增加，用户可能面临难以精确定位特定文件存储位置以及管理大量数据的挑战。</p><h3 id="2-2-HDFS的解决方法"><a href="#2-2-HDFS的解决方法" class="headerlink" title="2.2 HDFS的解决方法"></a>2.2 HDFS的解决方法</h3><h4 id="2-2-1-数据分块"><a href="#2-2-1-数据分块" class="headerlink" title="2.2.1 数据分块"></a>2.2.1 数据分块</h4><p>HDFS支持超大文件，它的分布式文件系统有较大的数据集，HDFS上的一个典型文件大小一般都在G字节至T字节。面临如此庞大的数据集，他主要采用了数据切块的方法。</p><p>数据块block是磁盘进行数据读写的最小单位，一个整体成为一个block块；在Hadoop2之后默认一个block块的大小为128M，当一个文件不是128的整数时，除了最后一个，每个数据块的大小都会保持一致，最后一个小于128M的数据也会单独使用一个块，以确保每个数据在获取时所需要的时间一致，便于使用和管理数据。</p><h4 id="2-2-2-数据定位"><a href="#2-2-2-数据定位" class="headerlink" title="2.2.2 数据定位"></a>2.2.2 数据定位</h4><p>HDFS采用master&#x2F;slave架构。一个HDFS集群是由一个NameNode和一定数目的DataNodes组成。</p><p>NameNode主要用于数据文件定位，内部存储文件的原数据信息，如文件归属、权限、大小等。DataNode则是存放文件的具体数据，存储在磁盘上。</p><p>在使用时，NameNode执行文系统的名字空间操作，如打开、关闭、重命名等，以及确定数据块到具体Datanode节点的映射。Datanode负责处理文件系统客户端的读写请求。在Namenode的统一调度下进行数据块的创建、删除和复制。</p><h4 id="2-2-3-数据冗余"><a href="#2-2-3-数据冗余" class="headerlink" title="2.2.3 数据冗余"></a>2.2.3 数据冗余</h4><p>由于HDFS是由大量的服务器组成的，即使一台服务器发生故障的概率极低，但随着服务器数量的提升，服务器会发生故障的概率就越高，所以硬件故障是常态，无法避免的。</p><p>为了解决这个问题，就需要对数据进行冗余，通常情况下，同一份数据会保存3份，其中两份存储在同一个机架上的不同服务器上，另一份数据储存在相邻机架的一台服务器上。</p><p>在文件写入的过程中，一般是客户端向NameNode发出创建文件请求，NameNode将应该存放文件的DateNode位置返回给客户端，然后客户端再连接具体的DateNode并发送写入的数据，数据写完后，会将数据副本发送给需要备份的位置，当所以副本写完以后，才会告诉NameNode一次写入完成。具体流程如下图所示。</p><p><img src="/images/HDFS%E5%82%A8%E5%AD%98%E6%B5%81%E7%A8%8B.png"></p><center>HDFS储存数据示意图</center><h3 id="3-HDFS的缺点"><a href="#3-HDFS的缺点" class="headerlink" title="3 HDFS的缺点"></a>3 HDFS的缺点</h3><p>不适用于低延迟数据的访问。数据切块和多份写入需要大量的时间，对比与MySQL这种毫秒级别的读写，有一定的差距。</p><p>不适合储存大量的小文件。每一个DateNode都是固定大小，当大量的小于固定大小的数据进行储存时候，会占用较多的空间，造成资源浪费。</p><p>不支持并发写。一个文件只允许一个进行写入，而且只能通过追加的方式写入，不能对已经写入的数据进行修改。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 ClickHouse 的用户画像实现分析</title>
    <link href="/2023/01/10/%E5%9F%BA%E4%BA%8E%20ClickHouse%20%E7%9A%84%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <url>/2023/01/10/%E5%9F%BA%E4%BA%8E%20ClickHouse%20%E7%9A%84%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="基于-ClickHouse-的用户画像实现分析"><a href="#基于-ClickHouse-的用户画像实现分析" class="headerlink" title="基于 ClickHouse 的用户画像实现分析"></a>基于 ClickHouse 的用户画像实现分析</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>用户画像作为一种重要的分析工具，对于企业洞察用户需求、提供个性化服务和增强竞争力具有重要意义。随着互联网和大数据技术的发展，企业可以通过收集和分析海量用户数据，深入了解用户的兴趣、偏好、行为习惯以及消费决策过程，从而更好地满足用户的需求。</p><p>通过用户画像，企业可以实现精准营销和个性化推荐，将产品或服务精准地推送给符合特定条件和兴趣爱好的用户群体。</p><h2 id="2-代码实战"><a href="#2-代码实战" class="headerlink" title="2 代码实战"></a>2 代码实战</h2><p>本案例采用clickhouse分析数据库，PostgreSQL关系型数据库，以顾客消费记录为例的用户画像分析。</p><h3 id="2-1-创建数据表"><a href="#2-1-创建数据表" class="headerlink" title="2.1 创建数据表"></a>2.1 创建数据表</h3><p>创建PostgreSQL外部数据用户表，作为数据分析的来源，接着创建ods本地表，通过外部用户表对其进行初始化操作。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">/** 创建PostgreSQL外部表 **/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> pg.users<br>(<br>    id       UInt32,<br>    gender  Enum8(<span class="hljs-string">&#x27;男&#x27;</span>=<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;女&#x27;</span>=<span class="hljs-number">2</span>),<br>    username String,<br>    cell_phone FixedString(<span class="hljs-number">11</span>),<br>    isVip    Int32 <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>,<br>    create_at DateTime<br>) ENGINE = PostgreSQL(<span class="hljs-string">&#x27;host:port&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;table&#x27;</span>, <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>);<br><br><span class="hljs-comment">/** 创建ODS本地表 **/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ods.users <span class="hljs-keyword">as</span> pg.users<br>ENGINE = MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_at);<br><br><span class="hljs-comment">/** 初始化数据 **/</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> ods.users <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pg.users <span class="hljs-keyword">WHERE</span> toDate(create_at) &lt; yesterday();<br></code></pre></td></tr></table></figure><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">/** 支付记录表结构 **/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> ods.payment_history<br>(<br>    id UInt64,<br>    user_id UInt32,<br>    amount Float32,<br>    create_at DateTime,<br>    order_id UInt256<br>)ENGINE = MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_at);<br></code></pre></td></tr></table></figure><h3 id="2-2-创建数据仓库"><a href="#2-2-创建数据仓库" class="headerlink" title="2.2 创建数据仓库"></a>2.2 创建数据仓库</h3><p>整合ODS层数据，创建DWD细节数据层，将所有的消费记录与用户信息进行连接，筛选掉注册后没有消费过的用户。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">/** #2 初始化DWD表 **/</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dwd.payment_history<br>ENGINE = MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> user_id<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> toYYYYMMDD(create_at)<br>    <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> a.id,<br>       a.user_id,<br>       a.amount,<br>       a.create_at,<br>       a.order_id,<br>       b.create_at <span class="hljs-keyword">as</span> user_create_at,<br>       b.gender,<br>       b.cell_phone,<br>       b.isVip,<br>       b.username<br><span class="hljs-keyword">FROM</span> ods.payment_history a<br><span class="hljs-keyword">LEFT JOIN</span> ods.users b <span class="hljs-keyword">ON</span> (a.user_id = b.id);<br></code></pre></td></tr></table></figure><h3 id="2-3-创建用户标签"><a href="#2-3-创建用户标签" class="headerlink" title="2.3 创建用户标签"></a>2.3 创建用户标签</h3><p>创建标签表，标签使用一级标签的定义，一级标签指的是一个标签仅显示标签名，没有进一步的细分。根据以及标签，我们创建两个标签。</p><p>高消费人群标签。统计数据表中所有的用户的消费金额，对其进行排序，然后消费金额最高的前5名将被定义为高消费人群。</p><p>夜猫子标签。筛选出所有在晚上0点到4点消费的用户，统计他们的消费次数，将消费次数最多的3位用户，打上夜猫子标签。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tf.user_tag<br>(<br>    tag_name String,<br>    user_id UInt32,<br>    create_at DateTime <span class="hljs-keyword">default</span> now()<br>)<br>engine = MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> tag_name<br><span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> toYYYYMMDD(create_at);<br></code></pre></td></tr></table></figure><h3 id="2-4-打标"><a href="#2-4-打标" class="headerlink" title="2.4 打标"></a>2.4 打标</h3><p>成功定义好标签之后，就可以开始为用户进行打标，达标的本质就是通过SQL将表中的数据写入到标签表中。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-comment">/** 高消费人群的标签 **/</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tf.user_tag<br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;高消费人群&#x27;</span> <span class="hljs-keyword">as</span> tag_name,<br>       b.user_id <span class="hljs-keyword">as</span> user_id<br><span class="hljs-keyword">FROM</span> (<br>      <span class="hljs-keyword">SELECT</span> user_id, sum(amount) <span class="hljs-keyword">as</span> total_amount<br>      <span class="hljs-keyword">FROM</span> dwd.payment_history a<br>      <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id<br>      <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> total_amount <span class="hljs-keyword">DESC</span><br>      <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">5</span><br>) b;<br><br><span class="hljs-comment">/** 夜猫子标签 **/</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tf.user_tag<br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;夜猫子&#x27;</span> <span class="hljs-keyword">as</span> tag_name,<br>       b.user_id <span class="hljs-keyword">as</span> user_id<br><span class="hljs-keyword">FROM</span> (<br>    <span class="hljs-keyword">SELECT</span> user_id,create_at,count(toHour(create_at)) <span class="hljs-keyword">as</span> times<br>    <span class="hljs-keyword">FROM</span> dwd.payment_history a<br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> user_id, create_at<br>    <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> times <span class="hljs-keyword">DESC</span><br>    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">3</span><br>) b<br><span class="hljs-keyword">WHERE</span> toHour(b.create_at) <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><h3 id="2-5-用户画像的使用"><a href="#2-5-用户画像的使用" class="headerlink" title="2.5 用户画像的使用"></a>2.5 用户画像的使用</h3><p>拥有了用户画像，企业在运营阶段就可以通过特征快速选择人群，并对其进行精准的营销。</p><p>通过某个标签，找出符合标签的人员列表，然后对其精准广告投放。比如某保健品店推出了最新的护肝片，需要对其进行推广，那么这时候就可以选中夜猫子标签，对拥有着标签的人进行广告投放。</p><p>当然我们也可以组合使用标签，选中高消费人群和夜猫子人群，获得喜欢在深夜高消费的人群列表，对这群人进行营销。比如电商平台推出了0点秒杀活动，那么就可以优先在这些人的主页上投放广告。</p><figure class="highlight postgresql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs postgresql"><span class="hljs-keyword">WITH</span><br>(<br>    <span class="hljs-comment">-- 筛选出夜猫子人群</span><br>    <span class="hljs-keyword">SELECT</span> tag_bitmap<br>    <span class="hljs-keyword">FROM</span> ads.tag_user_bitmap<br>    <span class="hljs-keyword">WHERE</span> toDate(create_at) = today() <span class="hljs-keyword">AND</span> tag_value = <span class="hljs-string">&#x27;夜猫子&#x27;</span><br>) <span class="hljs-keyword">AS</span> user_group_1,<br>(<br>    <span class="hljs-comment">-- 筛选出高消费人群</span><br>    <span class="hljs-keyword">SELECT</span> tag_bitmap<br>    <span class="hljs-keyword">FROM</span> ads.tag_user_bitmap<br>    <span class="hljs-keyword">WHERE</span> toDate(create_at) = today() <span class="hljs-keyword">AND</span> tag_value = <span class="hljs-string">&#x27;高消费人群&#x27;</span><br>) <span class="hljs-keyword">AS</span> user_group_2<br><span class="hljs-keyword">SELECT</span> bitmapToArray(bitmapAnd(user_group_1, user_group_2));<span class="hljs-comment">-- 对两个人群取交集</span><br></code></pre></td></tr></table></figure><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>用户画像是为企业使用者提供便利的工具，通过对客户进行分类，针对其特点推出相应的活动等。一个优秀的用户画像系统不仅仅反映具体数据，更需要将企业自身的业务和运营体系融入到画像制作中，以更好地应用用户画像</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用户画像</title>
    <link href="/2022/12/13/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/"/>
    <url>/2022/12/13/%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>用户画像（User Profile），是根据用户基本属性、社会属性、行为属性、心理属性等真实信息而抽象出的一个标签化的、虚拟的用户模型。“用户画像”的实质是对 “人”的数字化。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h2><p>用户画像的应用涉及多个方面，需要深入挖掘和分析各类用户数据，以实现精准的服务和营销策略。</p><p>洞察用户需求：用户画像可以帮助企业深入了解用户的偏好、喜好和行为习惯，从而预测用户需求，提前满足用户期望。</p><p>精准营销推广：基于用户画像，企业可以更精确地划定目标用户群体，开展有针对性的营销和推广活动，减少资源浪费，提高营销效果。</p><p>产品优化改进：通过用户画像，企业可以深入了解用户对产品的评价和反馈，从而及时调整产品策略和功能，提升产品的市场竞争力</p><p>用户增长和忠诚度提升：通过对用户画像的分析，企业可以制定个性化的用户增长和用户保持策略，提高用户的满意度和忠诚度。</p><h2 id="3-建立画像"><a href="#3-建立画像" class="headerlink" title="3 建立画像"></a>3 建立画像</h2><p>用户画像的建立总共分为四步：收集数据、清洗数据、分析数据、完善用户画像</p><h3 id="3-1-收集数据"><a href="#3-1-收集数据" class="headerlink" title="3.1 收集数据"></a>3.1 收集数据</h3><p>企业需要通过用户注册、问卷调查、社交媒体分析、日志记录等多种方式，来收集用户的各类数据，包括基本信息（如年龄、性别、地区）、行为数据（如浏览记录、购买行为）、兴趣爱好等。</p><h3 id="3-2-清洗数据"><a href="#3-2-清洗数据" class="headerlink" title="3.2 清洗数据"></a>3.2 清洗数据</h3><p>数据清洗是指在数据分析和挖掘过程中，对原始数据进行筛选、转换、整理和修正，以确保数据的质量和准确性。数据清洗是数据预处理的一个重要环节，其主要目的是消除数据中的错误、不一致和冗余，使数据更加符合分析需求和准确反映实际情况。</p><p>数据清洗主要包括四个方面：缺失值处理、异常值处理、数据格式统一化和冗余数据处理。通过这四方面的处理，可以确保数据的质量，提高分析的效率，并且减少误导性的分析。</p><h3 id="3-3-分析数据"><a href="#3-3-分析数据" class="headerlink" title="3.3 分析数据"></a>3.3 分析数据</h3><p>通过数据分析和挖掘技术，企业可以从海量的数据中提取有用的信息和模式。比如使用机器学习算法、数据挖掘技术，对用户数据进行聚类、分类、关联分析等，挖掘潜在的用户特征和行为规律。</p><h3 id="3-4-完善用户画像"><a href="#3-4-完善用户画像" class="headerlink" title="3.4 完善用户画像"></a>3.4 完善用户画像</h3><p>基于数据分析的结果，企业可以对用户进行综合描述和特征描绘，构建用户画像。用户画像可以包括用户的人口统计信息、行为偏好、兴趣爱好、购买能力等方面的内容，形成一个全面而准确的用户形象。</p><h3 id="3-5-用户画像的运用"><a href="#3-5-用户画像的运用" class="headerlink" title="3.5 用户画像的运用"></a>3.5 用户画像的运用</h3><p>以电商为例，模拟用户画像的构建过程。</p><p>首先可以通过查找数据库，收集到大量用户的消费数据。当有了这些数据，就需要对他们进行清洗，比如筛选掉退款、交易失败、已注销用户等数据。</p><p>在数据清洗完毕以后，通过查看有效数据中每一位消费者的id，购买物品、消费金额、消费时间等内容。可以分析出每位顾客消费偏向于哪一类商品、哪些用户喜欢在半夜买东西，又有哪些用户在某方面的商品上消费金额最多等现象，然后对这些消费者打上标签。这样就可以根据每一类客户推出不同的活动，来吸引顾客消费。</p><h2 id="4-存在的问题"><a href="#4-存在的问题" class="headerlink" title="4 存在的问题"></a>4 存在的问题</h2><p>数据隐私问题。用户数据的收集和使用需要遵循相关的法律法规，保护用户的隐私权。企业需要建立合规的数据采集和处理机制，确保数据安全和隐私保护。</p><p>数据质量问题：由于数据的来源和质量的差异性，可能会导致用户画像的准确性和完整性受到影响。因此，企业需要加强对数据的清洗和验证，提高数据的可信度和可用性。</p><p>技术挑战：用户数据的处理和分析需要庞大的计算资源和先进的算法技术。企业需要具备相应的技术能力，才能有效地构建和应用用户画像。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>综上所述，用户画像作为一种重要的分析工具，对于企业洞察用户需求、提供个性化服务和增强竞争力具有重要意义。但在应用过程中，也需要关注数据隐私保护、数据质量和技术挑战等问题。随着技术的不断发展和数据的不断积累，用户画像将在各行业中发挥越来越重要的作用，为用户和企业带来更好的体验和价值。</p>]]></content>
    
    
    <categories>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统下的IO</title>
    <link href="/2022/08/23/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84IO/"/>
    <url>/2022/08/23/Linux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E7%9A%84IO/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux系统下的IO"><a href="#Linux系统下的IO" class="headerlink" title="Linux系统下的IO"></a>Linux系统下的IO</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Java中的IO（输入&#x2F;输出）是以流为基础的机制，用于数据的输入和输出操作。它将数据串行化写入流，并进行输出。</p><p>Java的IO操作涉及磁盘、内存、网络和键盘等数据来源和目的地。使用输入流（InputStream）和输出流（OutputStream），可以实现数据的输入和输出操作。输入流用于从数据来源读取数据到内存，输出流用于将数据从内存写入数据源。</p><h2 id="2-磁盘IO的方法"><a href="#2-磁盘IO的方法" class="headerlink" title="2 磁盘IO的方法"></a>2 磁盘IO的方法</h2><p>磁盘IO共有三种方式：缓存IO、直接IO和内存映射。</p><h3 id="2-1-缓存IO"><a href="#2-1-缓存IO" class="headerlink" title="2.1 缓存IO"></a>2.1 缓存IO</h3><p>缓存IO又被称为标准IO，大多数文件系统的默认IO操作都是缓存IO，在Linux系统的缓存IO机制中，数据先从磁盘复制到内核空间的缓冲区(以页为单位)，然后从内核空间缓冲区复制到应用程序的地址空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">8192</span>); <br></code></pre></td></tr></table></figure><p>allocate（）方法就是一个常见的创建内存缓冲区的方法，这个方法是创建一个位置为0，最大容量位置为capacity,未设置标记位置的指定大小的缓冲区。</p><h4 id="2-1-1缓存IO的优势"><a href="#2-1-1缓存IO的优势" class="headerlink" title="2.1.1缓存IO的优势"></a>2.1.1缓存IO的优势</h4><p>通过利用页缓存，可以显著提高IO性能并减少对磁盘的访问次数。由于磁盘IO速度较慢，而内存访问速度更快，将文件数据缓存到内存中可以避免频繁地从磁盘读取数据。当应用程序请求读取文件数据时，内核首先检查页缓存中是否存在所需数据，若存在，则可以直接从缓存中读取，从而避免了额外的磁盘访问延迟。这不仅减少了对磁盘的实际访问次数，还显著提高了数据读取的速度。</p><p>此外，页缓存中的数据可供多个应用程序共享，从而避免了每个应用程序单独访问磁盘的开销。这种共享机制有助于减轻磁盘负载，并提升整体系统性能。 </p><p>当执行向文件写入数据的操作时，如果待写入数据所在的页缓存已存在，内核会直接将新数据写入到页缓存中。若待写入数据所在的页缓存不存在，则内核会先申请一个空闲的内存页（页缓存），然后从文件中读取数据到页缓存，并将新数据写入其中。对于被修改的页缓存，内核会定时将其刷新到文件中，以确保数据的一致性和持久性。</p><h4 id="2-1-2-缓存IO的劣势"><a href="#2-1-2-缓存IO的劣势" class="headerlink" title="2.1.2 缓存IO的劣势"></a>2.1.2 缓存IO的劣势</h4><p>缓存IO具有一些缺点，其中包括数据一致性和实时性难以保证。由于缓存IO的机制需要先将数据写入缓存，然后再刷新到底层存储设备，这会引入一定的延迟。如果在缓存中修改了数据，但尚未及时刷新到底层存储设备，而此时系统发生故障或崩溃，可能会导致数据丢失或不一致的情况。</p><p>此外，缓存IO需要使用一部分内存来存储缓存数据。如果缓存的数据量很大或者缓存管理不当，可能会导致内存消耗过大，从而影响系统的稳定性和性能。</p><h3 id="2-2-直接IO"><a href="#2-2-直接IO" class="headerlink" title="2.2 直接IO"></a>2.2 直接IO</h3><p>直接IO通过绕过内核缓存区，使应用程序可以直接访问磁盘上的数据，从而减少了从内核缓存区到应用程序之间的数据拷贝步骤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">8192</span>);<br></code></pre></td></tr></table></figure><p>allocateDirect()和缓存IO的创建方式类似，是创建一个位置为0，最大容量位置为capacity,未设置标记位置的指定大小的直接缓冲区。</p><p>在java代码中，allocate()和allocateDirect()方法的使用是没有明显区别体现的，无论是使用哪种方法创建的缓冲区，它们的使用方式和操作方法是相同的。区别体现在内存分配和释放的方式上，以及对于高性能 IO 操作的实际效果上。</p><h4 id="2-2-1直接IO的优势"><a href="#2-2-1直接IO的优势" class="headerlink" title="2.2.1直接IO的优势"></a>2.2.1直接IO的优势</h4><p>降低数据延迟和提高数据传输速度：直接I&#x2F;O减少了一次数据拷贝的过程，数据可以直接从外部设备传输到应用程序的内存中，或者从应用程序的内存传输到外部设备，从而减少了数据传输的延迟。这可以显著提高数据传输速度，特别是在大规模数据操作的情况下。</p><p>减少CPU负担：直接I&#x2F;O允许外部设备和主存储器之间的数据传输在硬件层面上完成，而不需要CPU的干预。这减轻了CPU的负担，使CPU能够更多地用于执行其他计算任务，提高了系统的效率和性能。</p><p>适用于大数据处理：直接I&#x2F;O对于大规模数据处理非常有效。它可以在数据传输期间同时进行其他计算任务，从而提高整体的数据处理能力。通过充分利用硬件资源，直接I&#x2F;O可以实现高吞吐量的数据操作，提高系统的效率和性能。</p><h4 id="2-2-2-直接IO的劣势"><a href="#2-2-2-直接IO的劣势" class="headerlink" title="2.2.2 直接IO的劣势"></a>2.2.2 直接IO的劣势</h4><p>直接IO有这么多优点，缺点也很明显。首先，它对专门的硬件支持有依赖，需要升级或更换现有系统的硬件，这增加了实施的成本和复杂性。其次，在实施直接IO时需要仔细考虑系统的安全性和稳定性，因为绕过内核缓存区可能引入安全风险，并需要采取适当的措施来确保数据的保密性和完整性。此外，直接I&#x2F;O的实现可能需要特定的API或接口来支持直接I&#x2F;O操作，这要求开发人员具备相应的技术知识和经验，增加了开发和维护的难度。</p><h3 id="2-3-内存映射"><a href="#2-3-内存映射" class="headerlink" title="2.3 内存映射"></a>2.3 内存映射</h3><p>内存映射是一种将文件或设备映射到进程的地址空间的机制，使得进程可以通过对内存的读写操作来访问文件或设备的内容。在内存映射中，操作系统将文件或设备的一部分或全部数据映射到进程的虚拟地址空间中的一个或多个内存区域。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> channel.map(MapMode mode, <span class="hljs-type">long</span> position, <span class="hljs-type">long</span> size); <br></code></pre></td></tr></table></figure><p>MappedByteBuffer map()方法是将通道文件的一个区域直接映射到内存中。映射一共有三种方式：READ_ONLY（只读模式）、READ_WRITE（读写模式）、PRIVATE（私有模式）。</p><h4 id="2-3-1-内存映射和直接I-O的区别"><a href="#2-3-1-内存映射和直接I-O的区别" class="headerlink" title="2.3.1 内存映射和直接I&#x2F;O的区别"></a>2.3.1 内存映射和直接I&#x2F;O的区别</h4><p>内存映射和直接I&#x2F;O是两种不同的数据访问机制。内存映射通过将文件或设备映射到进程的地址空间，使得进程可以通过对内存的读写操作来访问数据，而直接I&#x2F;O则通过绕过内核缓存区，直接访问磁盘上的数据进行读写。内存映射将数据映射到内存中，可以通过内存操作进行数据访问，而直接I&#x2F;O则需要使用特定的API或接口进行数据传输。内存映射不需要特殊的硬件支持，而直接I&#x2F;O可能需要专用硬件控制器和驱动程序的支持。内存映射适用于频繁访问文件或设备数据的场景，而直接I&#x2F;O对于大规模数据处理也非常有效。</p><h4 id="2-3-2-内存映射的优劣势"><a href="#2-3-2-内存映射的优劣势" class="headerlink" title="2.3.2 内存映射的优劣势"></a>2.3.2 内存映射的优劣势</h4><p>内存映射的优点包括简化的数据访问、提高性能和共享与协作。通过内存映射，进程可以使用常规的内存读写操作来访问文件或设备的数据，简化了编程过程并提高了代码的可读性。同时，内存映射避免了数据在内核缓存和用户空间之间的数据拷贝，从而显著提高了数据访问的速度和效率。此外，多个进程可以共享同一个文件或设备的数据，并通过对映射区域的修改实现进程间的数据传递和通信。</p><p>然而，内存映射也存在一些注意事项和缺点。文件大小限制是其中之一，由于内存空间的限制，一次性映射过大的文件可能会受到限制。此外，对映射区域的修改不一定会立即写入文件或设备，需要手动调用同步操作来确保数据的持久化，以避免数据丢失。映射大型文件可能会占用大量虚拟内存空间，需要合理规划和管理虚拟内存资源。最后，内存映射涉及将文件或设备的数据直接映射到进程的地址空间，需要注意安全性风险，确保适当管理和保护映射区域的权限。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>综上所述，Linux系统下的IO操作方法包括缓存IO、直接IO和内存映射。缓存IO利用页缓存提高了性能，但可能面临数据一致性和内存消耗问题。直接IO降低了延迟和CPU负担，适用于大规模数据处理，但需要硬件支持和安全性考虑。内存映射简化了数据访问、提高了性能和实现了数据共享，适合频繁访问数据的场景。了解不同的Linux系统下的IO方法及其特点，有助于开发人员根据具体需求选择合适的IO方式，以提高系统的性能和效率。未来的研究可以进一步探索优化IO操作的技术和方法，以满足不断增长的数据处理需求和提升系统的整体性能。</p>]]></content>
    
    
    <categories>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java内存区域详解</title>
    <link href="/2022/08/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/08/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Java内存区域详解"><a href="#Java内存区域详解" class="headerlink" title="Java内存区域详解"></a>Java内存区域详解</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>内存管理是操作系统的重要组成部分，它负责为进程分配和回收内存空间，以及对内存进行保护和优化。但是对于Java来说，在虚拟机自动内存管理机制的帮助下，不再需要对每个new操作去写配对的delete&#x2F;free代码，不容易出现内存泄漏和内存溢出的问题。</p><p>但是万一出现了内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误、修正问题将会成为一项异常艰难的工作。</p><h2 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2 运行时数据区域"></a>2 运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><p><img src="/images/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png"></p><center>Java虚拟机运行时数据区.png</center><h3 id="2-1-方法区"><a href="#2-1-方法区" class="headerlink" title="2.1 方法区"></a>2.1 方法区</h3><p>方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>《Java虚拟机规范》对方法区的约束是非常宽松的，不仅不需要连续的内存，而且可以选择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的确是比较少出现的，这片区域内存回收目标主要是针对常量池的回收和对类型的卸载。</p><p>方法区内有一部分空间为运行时常量池，是用于存放编译期生成的各种字面量与符号引用。</p><h3 id="2-2-堆"><a href="#2-2-堆" class="headerlink" title="2.2 堆"></a>2.2 堆</h3><p>对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。Java堆和方法区一样，也是被所有线程共享的一块内存区域，在虚拟机启动时创建。这片内存区域的唯一目的就是存放对象实例，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java堆是垃圾收集器管理的内存区域，也被称作“GC堆”。</p><h3 id="2-3-虚拟机栈"><a href="#2-3-虚拟机栈" class="headerlink" title="2.3 虚拟机栈"></a>2.3 虚拟机栈</h3><p>Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>虚拟机栈通常存放基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。</p><h3 id="2-4-本地方法栈"><a href="#2-4-本地方法栈" class="headerlink" title="2.4 本地方法栈"></a>2.4 本地方法栈</h3><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。</p><h3 id="2-5-程序计数器"><a href="#2-5-程序计数器" class="headerlink" title="2.5 程序计数器"></a>2.5 程序计数器</h3><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>在多线程的环境下，每一个线程都有一个独立的程序计算器，各个线程之间计数器互不影响，独立存储。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h2><p>以上部分，就是虚拟机里面的内存划分，每一个区域都拥有什么样的功能。只有了解了这些内容，才能在内存出现问题时，准确定位到问题区域，并采取相应的措施去解决问题。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Garbage First收集器</title>
    <link href="/2022/06/29/Garbage%20First%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <url>/2022/06/29/Garbage%20First%E6%94%B6%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Garbage First（简称G1）是一款主要面向服务端应用的垃圾收集器，它是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p><h2 id="2-Mixed-GC模式"><a href="#2-Mixed-GC模式" class="headerlink" title="2 Mixed GC模式"></a>2 Mixed GC模式</h2><p>垃圾收集器的设计师们希望能做出一款能建立起“停顿时间模型”的收集器，这个模型就是指在能够支持指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过N毫秒的模型。</p><p>针对这种目标，便出现了G1收集器的Mixed GC模式。它可以面向堆内存任何部分来组成回收集进行回收，衡量标准不是它属于哪个分代，而是哪块内存中存放的垃圾数量多，回收收益最大。</p><h2 id="3-实现思路"><a href="#3-实现思路" class="headerlink" title="3 实现思路"></a>3 实现思路</h2><p>G1不再坚持固定大小以及固定数量的分代区域划分，而是将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB,2MB, 4MB, 8MB, 1 6MB, 32MB。所有的Region大小相同，且在JVM生命周期内不会被改变。</p><p>每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。收集器能够对扮演不同角色的Region采用不同的策略去处理，这样无论是新创建的对象还是已经存活了一段时间、熬过多次收集的旧对象都能获取很好的收集效果。</p><p>G1收集器能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p><p><img src="/images/G1%E6%94%B6%E9%9B%86%E5%99%A8.png"></p><center>G1收集器Region分区示意图</center><h2 id="4-优缺点"><a href="#4-优缺点" class="headerlink" title="4 优缺点"></a>4 优缺点</h2><h3 id="4-1-优点"><a href="#4-1-优点" class="headerlink" title="4.1 优点"></a>4.1 优点</h3><p>并行与并发。G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。同时它还拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行。</p><p>分代回收。G1依然属于分代垃圾回收器，会区分年轻代和老年代。和其他收集器不同的是，他同时兼顾年轻代和老年代，不像其他的收集器，年轻代和老年代不能同时运行。</p><p>空间整合。CMS使用的是标记-清除算法，存在内存碎片化的情况，而G1将内存分为region，以此为单位回收，避免了碎片化的情况。</p><p>可预测停顿时间模型。</p><h3 id="4-2-缺点"><a href="#4-2-缺点" class="headerlink" title="4.2 缺点"></a>4.2 缺点</h3><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高。</p><h2 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5 使用场景"></a>5 使用场景</h2><p>第一种场景是内存足够大，达到8G以上才会推荐使用G1收集器；第二种场景是堆中存活的对象较多，可能占到对内存的50%左右，将会较容易触发full gc；第三种情况就是垃圾收集时间过长的时候会使用。</p>]]></content>
    
    
    <categories>
      
      <category>垃圾回收</category>
      
      <category>垃圾收集器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收详解</title>
    <link href="/2022/06/03/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/06/03/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收详解"><a href="#垃圾回收详解" class="headerlink" title="垃圾回收详解"></a>垃圾回收详解</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>垃圾回收（Garbage Collection，缩写为GC）是一种内存管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间，垃圾回收是最经典的守护线程。</p><h2 id="2-作用"><a href="#2-作用" class="headerlink" title="2 作用"></a>2 作用</h2><p>GC给程序员带来了非常大的便利。如果没有GC机制的存在，就必须要手动管理内存空间，确保需要的内存空间被保留，并释放不要的内存空间。这期间非常容易面临三个问题：内存泄漏、悬垂指针、错误的释放使用中的内存空间，从而引发恶性漏洞和系统崩溃。</p><p>有了GC以后，人们可以把内存管理托付给计算机，不需要考虑内存管理，把精力都集中在编程上。</p><h2 id="3-垃圾回收算法"><a href="#3-垃圾回收算法" class="headerlink" title="3 垃圾回收算法"></a>3 垃圾回收算法</h2><p>目前垃圾算法比较常见的共有4种，从出现时序来看，分别是：标记-清除算法、复制算法、标记-压缩算法和分代垃圾回收。</p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>标记-清除算法是由标记和清除两个阶段构成的。</p><p>标记阶段主要是从根节点出发，遍历根节点能到达的内存空间，将所有的活动对象都标记出来。</p><p>清除阶段，是将所有未标记的部分清除干净，并且对清理出来的连续空间进行合并，再将所有的空余空间链接到空闲链表上，方便之后的内存分配。最后再清除活动空间上的标记，为下一次垃圾回收做准备。</p><p><img src="/images/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4.png"></p><center>标记-清除算法</center><h4 id="3-1-1-优势"><a href="#3-1-1-优势" class="headerlink" title="3.1.1 优势"></a>3.1.1 优势</h4><p>实现比较简单。算法简单，相比于其他算法，更加容易实现；不需要对内存空间的数据进行挪动，可以与保守式GC算法兼容。</p><h4 id="3-1-2-劣势"><a href="#3-1-2-劣势" class="headerlink" title="3.1.2 劣势"></a>3.1.2 劣势</h4><p>碎片化。清理完的空间不进行整理，很容易出现很多细小的分块，即使总的空余空间足够大，但是由于没有一块完整的大空间，可能大致内存无法被分配。</p><p>分配速度慢。由于清理出来的空间都在空闲链表上，极端情况下，可能会需要遍历整个链表才能分配空间。</p><p>垃圾回收周期较长。在一次完整的回收流程，每个阶段都需要遍历一次内存空间，对程序的性能有一定的影响。</p><h2 id="3-2-复制算法"><a href="#3-2-复制算法" class="headerlink" title="3.2 复制算法"></a>3.2 复制算法</h2><p>复制算法是将整个内存空间等分为二，分别为From空间和To空间。当From空间被占满时会触发复制算法，将所有的活动对象都复制到To空间，然后将From和To空间互换。</p><p><img src="/images/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"></p><center>复制算法</center><h3 id="3-2-1-优势"><a href="#3-2-1-优势" class="headerlink" title="3.2.1 优势"></a>3.2.1 优势</h3><p>优秀的吞吐量。对比标记-清除算法，复制算法只需要遍历一次，将所有的活动对象复制到To空间即可，一次垃圾回收所需要的时间很短。</p><p>分配速度快且不会发生碎片化。所有的空闲空间都是一个连续的空间，当有新的对象需要空间时候，只需要在现有已用空间的末尾分配需要的空间即可，不会导致空间碎片化的情况出现。</p><h3 id="3-2-2-劣势"><a href="#3-2-2-劣势" class="headerlink" title="3.2.2 劣势"></a>3.2.2 劣势</h3><p>堆的使用效率低。需要有一半的内存空间闲置，资源浪费严重，是一个非常大的缺陷。</p><p>需要挪动对象。</p><h2 id="3-3-标记-压缩算法"><a href="#3-3-标记-压缩算法" class="headerlink" title="3.3 标记-压缩算法"></a>3.3 标记-压缩算法</h2><p>标记-压缩算法与标记-清除算法类似。分为标记和压缩两个阶段，标记阶段和之前的没有变化。压缩阶段是将所有的活动空间进行挪动，把所有的空闲空间放到一块。</p><p><img src="/images/%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9.png"></p><center>标记-压缩算法</center><h3 id="3-3-1优势"><a href="#3-3-1优势" class="headerlink" title="3.3.1优势"></a>3.3.1优势</h3><p>不会产生碎片化。对比标记-清除算法，垃圾回收结束后，所有的空闲空间都集中在尾部，没有碎片化的情况出现。</p><p>堆的使用效率高。不会出现复制算法那样只能使用半个堆的情况出现，可以更加充分的使用内存空间。</p><h3 id="3-3-2-劣势"><a href="#3-3-2-劣势" class="headerlink" title="3.3.2 劣势"></a>3.3.2 劣势</h3><p>成本较高。对比复制算法，标记-压缩算法需要多次遍历堆内存，消耗的成本较大。</p><h2 id="3-4-分代垃圾回收"><a href="#3-4-分代垃圾回收" class="headerlink" title="3.4 分代垃圾回收"></a>3.4 分代垃圾回收</h2><p>分代回收是目前最常用的垃圾回收算法。它将整个内存空间分为两大部分：新生代空间和老年代空间。新生代空间内又细分为生成空间和两个幸存空间。</p><p><img src="/images/%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E5%86%85%E5%AD%98%E7%A4%BA%E6%84%8F.png"></p><center>分代回收内存示意图</center><p>新生代空间。所有新创建的对象都被分配到生存空间中，在其头部记录为0，当生存空间被占满时，采用复制算法，将活动对象都复制到第一个幸存者空间，并且每一个被复制进来的活动对象的年龄增加1。</p><p>当第一个幸存者空间被占满时，再次启用复制算法，将第一个幸存空间的活动对象复制到第二个幸存者空间，并且年龄再加1。之后就是两个幸存者空间之间反复采用复制算法，等内部的对象年龄增加到一定数值，就将该对象放入到老年代中。</p><p><img src="/images/%E6%96%B0%E7%94%9F%E4%BB%A3%E7%A9%BA%E9%97%B4GC.png"></p><center>新生代GC回收示意图</center><p>老年代空间。被放入到老年代的对象，都是不容易转变成垃圾的，所有老年代的GC执行频率很低，老年代使用的是标记-清除算法。</p><h3 id="3-4-1-优势"><a href="#3-4-1-优势" class="headerlink" title="3.4.1 优势"></a>3.4.1 优势</h3><p>吞吐量得到改善。新生代在执行GC时，只需要遍历生成空间的对象即可，所消耗的时间较短。</p><h3 id="3-4-2-劣势"><a href="#3-4-2-劣势" class="headerlink" title="3.4.2 劣势"></a>3.4.2 劣势</h3><p>在部分程序中会出现反作用。当遇到某个程序，里面有大量的活的很久的对象，当启动GC后，会出现两个问题。新生代GC所需要的时间增多，老年代频繁地运行GC。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>综上所诉，垃圾回收是一种非常便利的机制，可以帮助我们减少很多不必要的麻烦，但是一款完美的垃圾回收机制是不存在的，每一种回收机制都有各自的优缺点。所以，这就要根据实际需求出现，选择一款合适的，并且缺点对自身影响较小的回收机制去使用。</p>]]></content>
    
    
    <categories>
      
      <category>垃圾回收</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解redo log原理和恢复机制</title>
    <link href="/2022/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3redo%20log%E5%8E%9F%E7%90%86%E5%92%8C%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/05/25/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3redo%20log%E5%8E%9F%E7%90%86%E5%92%8C%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解redo-log原理和恢复机制"><a href="#深入理解redo-log原理和恢复机制" class="headerlink" title="深入理解redo log原理和恢复机制"></a>深入理解redo log原理和恢复机制</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>大家都知道在事务中，redo log是用来保证持久性的，在SQL执行器执行SQL语句时，对于增、删、改操作都是内存上操作的，操作完后，该数据所在的数据页就会变成脏数据页，等待后台线程将该数据页刷进磁盘中。</p><p><img src="/images/redoLog%E6%B5%81%E7%A8%8B.png"></p><center>redo log流程.png</center><p>但是大家有没有想过一个问题，那就是在脏页还没有刷进磁盘，MySQL发生错误，会发生什么事情？</p><h2 id="2-误区"><a href="#2-误区" class="headerlink" title="2 误区"></a>2 误区</h2><p>有些人会认为，当发生这种情况的话，是通过undo log回滚到事务发生前的状态，然后重新进行数据的修改。这种想法是片面的，如果事务未被提交，MySQL就发生错误，确实是使用了undo log来恢复数据。</p><p>但是，假如事务已经被提交了，然后MySQL发生错误，那么有应该怎么办呢。</p><h2 id="3-redo-log"><a href="#3-redo-log" class="headerlink" title="3 redo log"></a>3 redo log</h2><p>redo log主要就是为了解决事务已经被提交，但脏页还未持久化，MySQL突然崩溃，导致数据丢失的问题出现的。将MySQL的写操作记录在redo log中，实现持久化，然后再在合适的时机更新到磁盘中去。</p><p>这时有人可能会疑惑，写redo log是磁盘IO，直接将数据写入磁盘也是一次磁盘IO，那为什么需要redo log，而不是直接将数据写入磁盘。</p><p>这里面主要涉及到redo log和写数据的一个差异，redo log是顺序IO，写数据是随机IO。</p><p>写redo log是按照固定的顺序循环写入，而写数据需要找到对应的位置，然后再增删改，所需要花费的时间更多，速度较慢。</p><h2 id="4-redo-log流程"><a href="#4-redo-log流程" class="headerlink" title="4 redo log流程"></a>4 redo log流程</h2><h3 id="4-1-redo-log-block"><a href="#4-1-redo-log-block" class="headerlink" title="4.1 redo log block"></a>4.1 redo log block</h3><p>当redo log被创建以后，并不是一条一条的去写入到磁盘中的，而是保存到block中，然后再以block为单位，一块一块的写入到磁盘中去的。一个redo log block是512字节，每个block都分为3部分：一个12字节的header块头，一个496字节的body块体，一个4字节的trailer块尾。</p><p>每一个redo log都被保存在496字节的body内。假设一个SQL语句会产生一组增、删、改操作，并且各生成一个对应的redo log，那么一个事务就会产生多个redo log，这些事务会持续不断的被写入到redo log block中，并且被标记成一个redo log group。</p><h3 id="4-2-redo-log-buffer"><a href="#4-2-redo-log-buffer" class="headerlink" title="4.2 redo log buffer"></a>4.2 redo log buffer</h3><p>所有的block都是存储在redo log buffer的连续内存缓冲区的，当事务被提交时，会把对应事务产生的redo log写入到磁盘中，实现持久化。</p><p>当然并不是只有事务提交时，redo log buffer里面的数据才会被刷入磁盘，还如存在以下情况。</p><p>log buffer空间不足。log buffer空间是有限的，如果不断地往里面塞入日志，有限的空间很快会被填满，所以当写入的日志量达到buffer总容量一半时，就会将这些数据全部落盘。</p><p>后台线程持续的输入。通常是一个后台线程，以每秒一次的频率，将redo log刷新到磁盘。</p><p>还有就是正常关闭服务器以及触发 <strong>checkpoint</strong> 规则时，也会触发日志刷新到磁盘中去。</p><h2 id="5-redo-log恢复数据"><a href="#5-redo-log恢复数据" class="headerlink" title="5 redo log恢复数据"></a>5 redo log恢复数据</h2><p>当redo log被持久化以后，MySQL发生错误并不会有太大影响。只要在重启时解析redo log中的事务然后重放一遍。将Buffer Pool中的缓存页重做成脏页，后续再在合适的时机将该脏页刷入磁盘即可。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务</title>
    <link href="/2022/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>数据库事务是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2 特性"></a>2 特性</h2><p>数据库事务一共有四大特性，分别是：原子性、一致性、隔离性和持久性。</p><p>原子性(Atomicity)。事务作为一个整体被执行，对数据库的操作要么全部被执行，要么都不执行。比如数据在写入过程中发生错误，他会回滚到事务发生前的状态。</p><p>一致性(Consistency)。是指事务在开始前和事务结束后，数据不会被破坏。比如A和B各有10块钱，A给B转10块钱，那么事务结束以后，A和B的账户一定是0和20，而不会其他的金额。</p><p>隔离性(Isolation)。多个事务并发时，事物之间是相互隔离的，互相之间不会被影响。</p><p>持久性(Durability)。事务发生以后，对数据库的更改都会被持久的写入到数据库中。</p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3 实现原理"></a>3 实现原理</h2><p>事务的四大特的实现，主要是依赖于所使用的存储引擎，分别是依靠redo log(重做日志)和undo log(回滚日志)，以及MVCC(多版本并发控制)来实现的。</p><p>undo log，主要实现了原子性。在事务发生时，undo log会记录事务发生前数据库的数据，如果出现异常，就会恢复到发生前的状态。如果事务正常提交，那么在一段时间内，这次记录的数据库数据会被删除。</p><p>redo log，实现了持久性。在事务进行写操作时，数据不是立刻反映在数据库的修改上的，而是先记录到redo log上，然后再通过异步的方式写进数据库，如果在写入过程中出现异常，也是可以通过redo log来重新写入的。</p><p>MVCC，保证了隔离性。它主要是保存多个数据版本，每一个版本都记录有版本的生成时间和过期时间，每一个并发事务都只能看到自己对应的数据版本。</p><p>至于一致性，主要是通过上诉三个一起来实现的。</p><h2 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4 缺点"></a>4 缺点</h2><p>事务在它存在的时候，给我们带来了很大的便利，但是它也存在着一定的缺陷。</p><p>并发性能损失。由于事务需要保证隔离性，可能会导致并发操作的性能下降。当多个事务同时操作相同的数据时，需要进行锁定和等待，从而影响系统的吞吐量。</p><p>锁争用和死锁。事务的隔离性可能导致锁争用和死锁问题。如果多个事务同时请求同一个资源，可能会发生死锁，导致系统无法继续执行。</p><p>容易引发长时间事务。事务需要在较短的时间内执行完成，否则可能会占用数据库资源，影响其他事务的执行。</p><p>需要额外的存储开销。为了保证事务的持久性，数据库需要记录事务日志以支持事务的回滚和恢复，这会增加存储开销。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>事务可以很好地保证我们数据的准确性，但是也需要在使用时注意一些缺点。在实际开发中，需要根据业务需求和系统特点合理地运用事务，以达到数据一致性和系统性能的平衡。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是线程安全</title>
    <link href="/2022/03/28/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2022/03/28/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>线程安全，是每一个从业者多无法避免的问题。那么什么是线程安全呢，首先先说一下线程。线程是进程中最小的执行单位，每一个程序里面都有至少一个线程。在单线程环境中，是不会发生线程安全问题的，只有在多线程环境下，才需要考虑。</p><h2 id="2-线程不安全"><a href="#2-线程不安全" class="headerlink" title="2 线程不安全"></a>2 线程不安全</h2><p>以下是一个非常经典的线程不安全的案例，当两个线程同时对一个变量进行10000次自增，那么结果会是20000嘛。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                add();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                add();<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        thread2.start();<br>        thread.join();<br>        thread2.join();<br>        System.out.println(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很显然，每一次运行上述代码，得出来的结果都不一样，但是没有一次的结果是20000。这就是线程不安全。</p><p>造成线程不安全的原因很简单，那就是整个自增操作不是原子性的。</p><h2 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3 线程安全"></a>3 线程安全</h2><p>当多个线程访问同一个方法时候，不管通过什么样的调用方式或者线程如何执行，最终得出来的结果一定是和预期值是一样的。就拿上面的例子来说，所谓的线程安全，那就是不论重复执行多少次代码，最后得出来的值一定是20000。</p><p>在Java中，实现线程安全的方法有很多。如使用线程同步，包括同步块、同步方法、可重入锁等；使用Volatile关键字；使用Atomic变量和使用final关键字。</p><h2 id="4-AtomicInteger实现线程安全"><a href="#4-AtomicInteger实现线程安全" class="headerlink" title="4 AtomicInteger实现线程安全"></a>4 AtomicInteger实现线程安全</h2><p>AtomicInteger是一个支持原子操作的Integer类，它提供了原子自增方法、原子自减方法以及原子赋值方法。接下来，我们以此为例，将上述线程不安全的代码修改成线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span>&#123;<br>        j.incrementAndGet();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                add();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                add();<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        thread2.start();<br>        thread.join();<br>        thread2.join();<br>        System.out.println(j);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过改写后的代码，已经实现了线程安全，无论对它执行多少次，得出来的结果一定是20000。</p><p> AtomicInteger 的线程安全性，但并不是所有场景都适用，它主要用于多线程环境中的计数器、序列生成器等场景。需要注意的是，AtomicInteger 只保证单个原子操作的线程安全，如果需要在多个原子操作之间保持一致性，还是需要使用其他同步机制。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>线程安全是我们经常会遇到的问题，解决方法也有很多。但是对于工作时间较短的程序来说，这是一块让人非常头疼的问题。只有我们弄清楚了线程不安全是由什么原因造成的，才能对症下药，要到合适的处理方法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>线程安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储结构-索引</title>
    <link href="/2022/03/26/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/03/26/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="存储结构-索引"><a href="#存储结构-索引" class="headerlink" title="存储结构-索引"></a>存储结构-索引</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>索引是关系数据库中的一种存储结构，它的作用相当于图书目录，可以根据目录中的页码快速找到所需的内容，可以大幅提升查找的效率。所以他也是MySQL面试中的重中之重，所以我们现在就简单的说说索引。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><p>所先我们来看一下索引的分类，总共可以从三个维度对索引进行分类。从基本使用上，可以分为主键索引、唯一索引、普通索引和组合索引；从数据结构上来分，可以分为哈希索引、B树索引和B+树索引；而从物理存储上来分的话。可以分为聚簇索引和非聚簇索引。</p><h2 id="3-MySQL索引的数据结构"><a href="#3-MySQL索引的数据结构" class="headerlink" title="3 MySQL索引的数据结构"></a>3 MySQL索引的数据结构</h2><p>MySQL的默认存储引擎是InnoDB,采用的是B+数结构的索引。</p><h3 id="3-1-B-树"><a href="#3-1-B-树" class="headerlink" title="3.1 B+树"></a>3.1 B+树</h3><p>B+树是一种只有叶子节点才会存储数据，非叶子节点只存储键值得结构，叶子节点之间是用双向指针连接，最底层的叶子节点形成一个双向有序链表。<br><img src="/images/B+%E6%A0%91%E7%BB%93%E6%9E%84.png"></p><center>B+树结构</center>如图所示，B+树一共分为三层，每次外面包裹的成为磁盘块，每一个磁盘块都包含两个数据项和三个指针，如根节点磁盘包含的数据项为20和38，三根指针分别表示小于20,20-38之间以及大于38的磁盘块。真实的数据都存在于第三层叶子节点上，非叶子节点上所存储的只是搜索方向的数据项，并不一定存在于数据中。同时，叶子节点之间还使用了双向指针连接，形成一个双向的有序链表，可以提供范围查询的功能。<h3 id="3-2-B-树的特点"><a href="#3-2-B-树的特点" class="headerlink" title="3.2 B+树的特点"></a>3.2 B+树的特点</h3><h4 id="3-2-1-和B树相比"><a href="#3-2-1-和B树相比" class="headerlink" title="3.2.1 和B树相比"></a>3.2.1 和B树相比</h4><p>B+树是B树的变种，都可以解决每个节点存储更多关键字和路数更多的需求。同时它的磁盘读写能力更强，IO次数更少；<br>因为B+树的根节点和枝节点都不保存数据，节点所以一个节点可以保存更多的关键字，一次磁盘的加载获取的数据更多，所以IO次数更少。而B树的枝节点保存数据，占据的空间更大，需要加载的时间更多。</p><h4 id="3-2-2-其他特点"><a href="#3-2-2-其他特点" class="headerlink" title="3.2.2 其他特点"></a>3.2.2 其他特点</h4><p>B+树的扫库、扫表能力更强，因为他只需要遍历叶子节点就可以获取所有的数据；<br>排序能力更强，效率也更加稳定。这都是得利于叶子节点上的指针，将两个数据区连接成了链表，并且B+树永远在叶子节点上获取数据，IO次数也比较稳定。</p><h2 id="4-聚簇索引"><a href="#4-聚簇索引" class="headerlink" title="4 聚簇索引"></a>4 聚簇索引</h2><p>上文提到，聚簇索引是一种存储方式，表示数据行和相邻的键值紧凑的存储在一起，InnoDB才用的就是聚簇索引。<br>简单来说，聚簇索引就是索引和数据都存储在一棵树上，树的叶子节点就是数据。与之相对的就是非聚簇索引，它的索引和数据不在一棵树上，MyISAM采用的就是这一种方式。</p><h3 id="4-1-两者之间的对比"><a href="#4-1-两者之间的对比" class="headerlink" title="4.1 两者之间的对比"></a>4.1 两者之间的对比</h3><p>在一个表中，聚簇索引只能有一个，但是可以有多个非聚簇索引；<br>在聚簇索引中，索引的键值逻辑顺序决定了表中相应行的物理顺序，而非聚簇索引就没有这种情况。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>索引是一个非常强大的存储结构，它可以很大程度的提升数据库的查找效率，但是我们也要明白其中的一些原理，只有这样我们才能更好的使用好索引。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>索引</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程下的HashMap</title>
    <link href="/2022/01/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84HashMap/"/>
    <url>/2022/01/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程下的HashMap"><a href="#多线程下的HashMap" class="headerlink" title="多线程下的HashMap"></a>多线程下的HashMap</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>HashMap是Java中常用的数据结构，基于哈希表实现，用于存储键值对映射关系。通过合理的哈希函数和散列冲突解决方法，HashMap能够在各种场景中发挥重要作用。</p><p>由于HashMap不是线程安全的，所以在多线程环境下存在着很多问题，对于这些问题，如果处理不得当，可能会带来很多麻烦。</p><h2 id="2-多线程下的问题"><a href="#2-多线程下的问题" class="headerlink" title="2 多线程下的问题"></a>2 多线程下的问题</h2><h3 id="2-1-扩容死循环"><a href="#2-1-扩容死循环" class="headerlink" title="2.1 扩容死循环"></a>2.1 扩容死循环</h3><p>在JDK1.7中，HashMap的扩容采用的是头部插入法。在多线程环境下，扩容的时候有可能会产生环形链表，造成死循环。</p><h3 id="2-2-插入数据丢失"><a href="#2-2-插入数据丢失" class="headerlink" title="2.2 插入数据丢失"></a>2.2 插入数据丢失</h3><p>在多线程环境下，多个线程同时进行put操作。如果他们计算出来的索引位置是相同的，那么可能会出现后一个key将前一个key覆盖，从而导致数据丢失。</p><h3 id="2-3-访问为空"><a href="#2-3-访问为空" class="headerlink" title="2.3 访问为空"></a>2.3 访问为空</h3><p>多线程环境下，两个线程一个put，一个get。如果在put操作时，刚好触发了扩容机制，此时另一个线程进行get操作，可能会造成get的值为null的情况出现。</p><h2 id="3-解决方法"><a href="#3-解决方法" class="headerlink" title="3 解决方法"></a>3 解决方法</h2><p>面对上面的三个问题，就需要找到对应的解决方法。</p><p>对于扩容死循环问题，可以直接使用JDK1.8的HashMap，它使用了尾部插入元素，在扩容的时候会保持链表原本顺序，不会出现话环形链表的情况。</p><p>另外两个问题，可以使用线程安全的Map来解决，如HashTable，Collections.synchronizedMap以及ConcurrentHashMap。</p><h3 id="3-1-ConcurrentHsahMap"><a href="#3-1-ConcurrentHsahMap" class="headerlink" title="3.1 ConcurrentHsahMap"></a>3.1 ConcurrentHsahMap</h3><p>ConcurrentHsahMap是线程安全的Map，它在JDK1.7和JDK1.8中采用了两种不同的实现方法。</p><p>JDK1.7中，它采用了分段锁的机制，里面包含一个Segment数组，继承于ReentrantLock，内部包含HashEntry的数组。实际上就是相当于每个Segment都是一个HashMap，默认的Segment长度是16，也就是支持16个线程的并发写，Segment之间相互不会受到影响。</p><p><img src="/images/ConcurrentHsahMap.png"></p><center>ConcurrentHsahMap示意图</center><p>JDK1.8中，线程安全的实现不是依靠改变数据结构来保证线程安全了，而是通过对put流程的更改来实现的，主要就是在初始化、数组写入和扩容时采用CAS的方式，在插入数据时，采用synchronized的方式，来确保线程安全问题。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>使用线程安全的Map实现可以避免插入数据丢失和访问为空的问题，但需要注意在并发写入时仍可能存在覆盖或更新数据的情况，需要根据具体需求选择合适的并发控制策略。</p><p>综上所述，针对多线程环境下的问题，可以选择使用JDK1.8及以上版本的HashMap或线程安全的Map实现类来解决。同时，根据具体需求和性能要求，合理选择合适的并发控制策略，以确保数据的一致性和线程安全。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程的锁</title>
    <link href="/2022/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%81/"/>
    <url>/2022/01/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程的锁"><a href="#多线程的锁" class="headerlink" title="多线程的锁"></a>多线程的锁</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Java锁是Java编程语言中用于实现多线程同步和互斥的机制。在并发编程中，多线程可能会出现线程竞争，数据不可见等其他并发问题，Java锁提供了一种控制多线程并发访问的方式，以确保线程安全和正确的数据访问。</p><h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2 分类"></a>2 分类</h2><p>锁的分类较多，有多个维度。按照锁粒度来分，可以分为表锁、页锁和行锁；按照锁模式来分，可分为记录锁、间隙锁、意向锁、插入意向锁等；按照加锁机制可分为乐观锁和悲观锁；按照兼容性又可以分为共享锁和排他锁。本文主要阐述多线程下的悲观锁机制。</p><h2 id="3-悲观锁的实现"><a href="#3-悲观锁的实现" class="headerlink" title="3 悲观锁的实现"></a>3 悲观锁的实现</h2><p>悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。Java中Synchronized和ReentrantLock等独占锁就是悲观锁思想实现的。</p><h3 id="3-1-同步块"><a href="#3-1-同步块" class="headerlink" title="3.1 同步块"></a>3.1 同步块</h3><p>同步块加锁是一段代码或者一个方法被synchronized关键字标记，就可以称之为同步块代码，它可以用来避免线程竞争。</p><h4 id="3-1-1-在类上加锁"><a href="#3-1-1-在类上加锁" class="headerlink" title="3.1.1 在类上加锁"></a>3.1.1 在类上加锁</h4><p>将需要同步的代码块放在一个代码块内部，并使用<code>synchronized</code>关键字指定一个类作为同步锁，即<code>synchronized (MyClass.class)</code>。这样可以通过类级别的锁来保护同步代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLevelLockExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedStaticMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (ClassLevelLockExample .class) &#123; <span class="hljs-comment">// 使用类级别的锁</span><br>            <span class="hljs-comment">// 需要同步访问的代码块</span><br>            System.out.println(<span class="hljs-string">&quot;进入 synchronizedStaticMethod&quot;</span>);<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-1-2-在对象上加锁"><a href="#3-1-2-在对象上加锁" class="headerlink" title="3.1.2 在对象上加锁"></a>3.1.2 在对象上加锁</h4><p>将需要同步的代码块放在一个代码块内部，并使用<code>synchronized</code>关键字指定一个对象作为同步锁。通常情况下，我们可以使用当前对象作为同步锁，即<code>synchronized (this)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectLevelLockExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123; <span class="hljs-comment">// 使用对象级别的锁</span><br>            <span class="hljs-comment">// 需要同步访问的代码块</span><br>            System.out.println(<span class="hljs-string">&quot;进入 synchronizedMethod&quot;</span>);<br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-同步方法"><a href="#3-2-同步方法" class="headerlink" title="3.2 同步方法"></a>3.2 同步方法</h3><p>当synchronized作用于一个方法上时，这个方法就被称为同步方法。一个同步实例方法在java中是同步与对象实例的方法上。因此每个实例有它自己的同步方法同步在不同的对象上。</p><h4 id="3-2-1-在类上加锁"><a href="#3-2-1-在类上加锁" class="headerlink" title="3.2.1 在类上加锁"></a>3.2.1 在类上加锁</h4><p>对于静态方法，可以使用<code>synchronized</code>关键字来修饰方法，以实现类级别的锁。使用类级别的锁可以保护静态方法内的代码块，确保同一时间只有一个线程可以访问该静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedStaticMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 需要同步的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-2-在对象上加锁"><a href="#3-2-2-在对象上加锁" class="headerlink" title="3.2.2 在对象上加锁"></a>3.2.2 在对象上加锁</h4><p>在方法声明前使用<code>synchronized</code>关键字来修饰方法。这样的方法被称为同步方法，因为它们使用对象级别的锁来保护方法内的代码块。当线程访问同步方法时，会自动获取该方法所属对象的锁，并在执行完毕后释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 需要同步的代码块</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-3-可重入锁"><a href="#3-2-3-可重入锁" class="headerlink" title="3.2.3 可重入锁"></a>3.2.3 可重入锁</h4><p>Java提供了<code>Lock</code>接口及其实现类（如<code>ReentrantLock</code>），用于实现显式加锁和解锁。显式锁需要手动调用<code>lock()</code>方法来获取锁，并在适当的时候调用<code>unlock()</code>方法来释放锁。相比于<code>synchronized</code>关键字，显式锁提供了更多的灵活性，可以实现更复杂的同步需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronizedMethod</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 需要同步的代码块</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，是用Lock接口，一定要记得使用unlock()方法释放锁，否则会出现非常严重的后果。如死锁和资源泄露。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>总体而言，多线程锁是实现并发编程中线程安全和正确数据访问的重要机制。合理地使用锁可以避免线程竞争和数据不一致的问题，提高程序的并发性能和可靠性。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/2021/12/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <url>/2021/12/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>多线程是指从软件或硬件上实现多个线程并发的技术。代码在数据集合上的一次运行活动，被称为进程，进程是操作系统在分配和调度资源的基本单位，而线程是进程的一个执行路径，一个进程里面有用一个或者多个线程。</p><h2 id="2-多线程的作用"><a href="#2-多线程的作用" class="headerlink" title="2 多线程的作用"></a>2 多线程的作用</h2><p>提升程序的响应性和并发性。多线程程序可以同时处理多个任务请求，当遇到非常耗时的任务，可以使用多线程将其拆分成多个小任务，改善程序结构。也可以使用一个线程去运行，别的线程继续执行，避免长时间的堵塞造成时间上的浪费。</p><p>充分利用处理器。随着计算机的发展，电脑通常拥有多个核心，这就可以将多线程任务分配进不同的核心并发执行任务，提升效率。</p><h2 id="3-内存模型"><a href="#3-内存模型" class="headerlink" title="3 内存模型"></a>3 内存模型</h2><p>Java的内存模型是一种抽象的模型，它定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程可以操作的共享内存副本。</p><p><img src="/images/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p><center>内存模型示意图</center><h2 id="4-多线程的一些问题"><a href="#4-多线程的一些问题" class="headerlink" title="4 多线程的一些问题"></a>4 多线程的一些问题</h2><p>多线程是一个非常好的机制，可以很大程度的降低代码复杂度。但是如果使用不当，也会带来很多问题。</p><h3 id="4-1-线程竞争"><a href="#4-1-线程竞争" class="headerlink" title="4.1 线程竞争"></a>4.1 线程竞争</h3><p> 在单线程的程序中，所有的代码都是一行一行的去执行的，只要代码本身没有错误，那么得到的结果就和代码逻辑是一致的。但是，在多线程的环境下，由于上下文切换的原因，可能会导致原子性的问题。</p><p>比如一个自增的代码，在多线程环境中，线程A开始，先获取到初始值，这时突然发生切换，进入到线程B，那么B获取初始值，自增后写入内存，此时再发生上下文切换。虽然线程B已经对变量进行过一次自增，但由于线程A获取到的还是初始值，那么就会导致自增后，该变量的值只进行了一次自增。</p><h3 id="4-2-数据可见性"><a href="#4-2-数据可见性" class="headerlink" title="4.2 数据可见性"></a>4.2 数据可见性</h3><p>在单线程环境中，程序的每一步更改的值，后续步骤所拿到的一定是最新状态的值。然后在多线程环境下，每一个线程的变量都储存在各自的本地内存中，那么当线程A更改完某一变量以后，线程B需要去获取该变量时候。就会因为线程之间数据相互独立，不发互相访问的原因，使得线程B无法获取最新的数据，导致程序出错。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>多线程是一个非常便利的技术，可以给我们带来不少的便利，但同时我们也需要去进一步的了解里面的原理。不然的话，盲目的使用多线程，不仅无法享受到它所带来的便利，反而会给自己带来更多的困扰。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2021/10/21/HashMap/"/>
    <url>/2021/10/21/HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>HashMap是Java中常用的数据结构，它基于哈希表实现，用于存储键值对(key-value)映射关系。HashMap实现了Map接口，允许键和值为null，并且具有快速的访问速度。</p><p>在HashMap中，数据的存储是根据键的HashCode值来进行的，这样可以实现快速的查找和插入操作。另外，HashMap是无序的数据结构，即不会按照插入顺序或者其他顺序来存储键值对，因此在遍历HashMap时不能保证元素的顺序性。</p><h2 id="2-使用场景"><a href="#2-使用场景" class="headerlink" title="2 使用场景"></a>2 使用场景</h2><p>HashMap在Java中被广泛应用于各种场景，特别适合以下情况：</p><p>数据索引：HashMap适用于需要根据唯一标识（键）快速查找对应数值（值）的场景，比如数据库查询结果的缓存、内存中的数据索引等。</p><p>缓存管理：HashMap常被用作缓存数据的存储结构，可以提高数据的访问速度。例如，可以将经常使用的数据存储在HashMap中，避免频繁的数据库查询或计算过程。</p><p>频繁插入、删除和查找操作：由于HashMap基于哈希表实现，具有较好的性能，适合在需要频繁进行插入、删除和查找操作的场景中使用。</p><p>排重操作：对于需要去重的数据集合，可以使用HashMap来快速实现去重操作，通过将元素作为键存储在HashMap中，实现快速的去重功能。</p><h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h2><p>在JDK1.7中，HashMap的数据结构是数组+链表，在JDK1.8中数据结构为数组+链表+红黑树。</p><p><img src="/images/HashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p><center>HashMap数据结构</center><p>HashMap保存数据的原理很简单，首先是数据元素通过映射关系，映射到桶数组对应索引的位置上；如果发生了冲突，那么就生成一个链表，将有冲突的元素放入；如果一个链表的长度大于8，并且数组的大小大于等于64，那么就将这个链表转变成红黑树；如果一个红黑树的节点个数小于6个时，红黑树会转变成链表。</p><h3 id="3-1-扰动函数"><a href="#3-1-扰动函数" class="headerlink" title="3.1 扰动函数"></a>3.1 扰动函数</h3><p>在数据进行映射时，总共需要经历两部分的运算，第一部分就是扰动函数。</p><p>HashMap的哈希函数是先拿到key的hashhode，所有就需要再对hashcode的高16位和低16位进行异或运算，这样下来散列值分布的就松散了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span>&#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashcode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-取模运算"><a href="#3-2-取模运算" class="headerlink" title="3.2 取模运算"></a>3.2 取模运算</h3><p>经过扰动函数以后，他的值依旧是一个32位的int值，他的范围一共有40亿个映射空间，内存是放不下的，所以还需要对这个值进行取模运算。</p><p>取模运算就是将散列值和数组长度-1做“&amp;”运算，经过这个算法，最终会得到一个4位数的值，经过进制转换，就能得到一个满足需求的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">bucketIndex = indexFor(hash,table.length);<br><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h,<span class="hljs-type">int</span> length)</span>&#123;<br><span class="hljs-keyword">return</span> h &amp; (length - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>经过扰动函数和取模运算，就能解决散列值分布不松散的情况出现，降低了哈希碰撞的概率。</p><h2 id="4-哈希碰撞"><a href="#4-哈希碰撞" class="headerlink" title="4 哈希碰撞"></a>4 哈希碰撞</h2><p>哈希碰撞是不可避免的，即使通过扰动函数降低了碰撞的概率，但是碰撞还是存在的。面对哈希碰撞，常规的方法就是使用链地址法。所谓的链地址法就是在冲突的位置拉一个链表，把有冲突的元素放进去。</p><p>当然，链地址法并不是唯一的处理方法，还有其他的一些方法：开放定址法、再哈希法和建立公共溢出区。</p><p>开放定址法：从冲突位置再接着往下找，找到的空位就把位置给冲突元素。</p><p>在哈希法：换一种哈希函数，重新计算冲突元素的地址。</p><p>建立公共溢出区：再建一个数组，把冲突的元素放进去。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>HashMap是Java中常用的数据结构，基于哈希表实现，用于存储键值对映射关系。通过合理的哈希函数和散列冲突解决方法，HashMap能够在各种场景中发挥重要作用。</p><p>了解HashMap内在的原理有助于更好地利用它，并且在面对大规模数据、性能需求高的场景时能够做出更好的选择和优化。HashMap在实际工作中的运用需要综合考虑容量、负载因子、线程安全等因素，同时也需要关注其在多线程环境下的安全性。对HashMap的深入了解有助于我们充分发挥其优势，同时避免潜在的问题，提高代码的质量和性能。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
